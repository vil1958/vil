## МЯГКИЕ И ЖЕСТКИЕ ССЫЛКИ В LINUX

### Мы уже рассказывали про 

### мягкие и жесткие ссылки в Linux

### , и данная статья посвящена их более глубокому изучению. Ссылки в операционной системе Linux бывают 2-х типов 

**

### мягкие

**

###  и 

**

### жесткие

**

### . Если провести аналогию с операционной системой Windows, то там мы в основном работаем с мягкими ссылками, символическими ярлыками. Но в операционной системе Windows есть и жесткие ссылки, просто они очень глубоко спрятаны внутри операционной системы. В статье будет рассказано:

• Как идентифицировать тип ссылки

• В чем разница между мягкой и жесткой ссылкой

• В чем разница между копирование и создание ссылки

ls -l

### Итак, смотрим в домашнюю директорию пользователя. Я заранее создал файл и 2 ссылки жесткую и мягкую указывающие на данный фай

л

[![file://e:/Temp/app/.SBYMW1/1.png](file://e:/Temp/app/.SBYMW1/1.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/1.png)

### Основной файл 

`file.txt`

### , жесткая ссылка 

`hard.txt`

###  на файл 

`file.txt`

###  и мягкая ссылка 

`soft.txt`

###  на файл 

`file.txt`

### . Как можно заметить символические (мягкие) ссылки в оболочке, обычно, подкрашиваются ярко голубым цветом и показывают на какой файл она ссылается. Можно еще интересную вещь заменить основной файл весит 38 килобайт и жесткая ссылка столько же весит. Мягкая ссылка – это всего лишь ярлык и весит всего 8 килобайт. Посмотрим, что внутри файла основного. Файл содержит фраз

[![file://e:/Temp/app/.SBYMW1/2.png](file://e:/Temp/app/.SBYMW1/2.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/2.png)

ls -li

### Команда 

`ls`

###  с ключем 

`–li`

###  может отображать 

**inodes**

### . В результате ввода команды появился еще один столбец впереди. В данном столбце и отображается номер inodes, т.е идентификатор файла, индексный дескриптор, местонахождение файла на диске, метка файла.

[![file://e:/Temp/app/.SBYMW1/3.png](file://e:/Temp/app/.SBYMW1/3.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/3.png)

### В нашем же случае номера inodes у файла и у жесткой ссылки совпадает. Т.е жесткая ссылка указывает на то же место, где находиться основной файл, в то же самое место на жестком диске. Мягкая же ссылка, сама по себе является отдельным файлом и у нее совершенно другой inode. А также можно видеть, что у данного файла в правах появилась буква 

`l`

### , которая указывает что это символьная ссылка. Причем попробовав просмотреть содержимое жесткой и мягкой ссылки, мы получим одинаковый результат. Все показывает на один и тот же файл.

cat file.txt

cat soft.txt

cat hard.txt

[![file://e:/Temp/app/.SBYMW1/4.png](file://e:/Temp/app/.SBYMW1/4.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/4.png)

### Если мы попробуем дописать, какие-нибудь изменения в файл. Например, 

`echo Hello>> file.txt`

`echo Hello>> file.txt`

cat file.txt

cat soft.txt

cat hard.txt

[![file://e:/Temp/app/.SBYMW1/5.png](file://e:/Temp/app/.SBYMW1/5.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/5.png)

### Получим один и тот же результат. Возьмем и переименуем наш основной файл 

`mv file.txt newfile.txt`

`mv file.txt newfile.txt`

[![file://e:/Temp/app/.SBYMW1/6.png](file://e:/Temp/app/.SBYMW1/6.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/6.png)

ls -l

### Теперь мы можем увидеть, что ссылка мягкая у нас стала красной (Битой). Потому что, мягкие ссылки опираются на имя файла. Причем не просто на имя файла, а на полное имя файла. А жесткая ссылка, как была, так и осталась работоспособной. Потому, что она указывает на один и тот же inode, потому что она указывает на то место где данный файл находиться. И если мы утилитой cat скажем показать жесткую ссылку в выводе мы получим исходный файл, а мягкая ссылка выдаст нам ошибку. Основная разница между жесткой ссылкой и мягкой, заключается в том, что мягкая опирается на имя файла. А жесткая указывает на физическое место, определяемое дескриптором где находиться файл

### Т.к. жесткая ссылка у нас привязана к inode, то ее нельзя использовать с несколькими файловыми системами. Если у вас есть другой жесткий диск премонтированый в данную файловую систему, то вы не сможете создать жесткую ссылку из данной системы к премонтированному жесткому диску. Потому, что это все опирается на inode, а inode справедливы для конкретной файловой системе. Поэтому в операционной системе Windows все ссылки по умолчанию мягкие. Пригодиться это может где угодно. Например, мы в своей домашней директории можем создать ссылки на все свои важные папки или данные. Очень часто символические ссылки используются для администрирования. Операционной системы Linux. Например, для команд, если пользователь не хочет знать номер версии или дополнительные ключи, он может просто получать доступ к различным версиям просто используя ссылки.

### Также стоит упомянуть ситуацию с папками.

### Создадим папку - 

`   ### mkdir Folder   `

### . Попробуем создать жесткую ссылку на данную папку - 

`   ### ln Folder folder.lnk   `

### , данная команда выдаст ошибку указывая на то, что нельзя создать жесткую ссылку на папку, но, а если мы захотим создать мягкую (символическую ссылку), то проблемы не возникнет - 

`   ### ln –s Folder folder.lnk   `

[![file://e:/Temp/app/.SBYMW1/7.png](file://e:/Temp/app/.SBYMW1/7.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/7.png)

### Хорошим тоном при создании ссылок символических это указание на полный путь файлу, т.к привязка идет к имени файла и при создании если указать относительны, мы можем столкнуться с ситуацией, когда получившаяся ссылка будет битой. Например, когда мы хотим создать ссылку на файл и положить ее во внутрь другие папки 

`   ### ln –s /home/siadmin/file.txt Folder/   `

### . данный вариант будет рабочим.

### Разница между копирование файла и созданием ссылки. Когда копируем файл мы фактически создаем другой файл со всем его содержимым, а когда мы создаем ссылку – это некий ярлык на файл. Скопируем файл 

`   ### file.txt   `

###  в 

`   ### newfile.txt   `

###  и на 

`   ### file.txt   `

###  создадим жесткую ссылку. Когда мы смотрим вывод команды 

`   ### ls –l   `

###  по папке то визуально копию мы не отличим от жесткой ссылки, если мы конечно об этом не знаем. А отличие мы увидим только если мы посмотрим на inodes.

ls -li

[![file://e:/Temp/app/.SBYMW1/8.png](file://e:/Temp/app/.SBYMW1/8.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/8.png)

### Как мы видим номера inode у файла и жесткой ссылки совпадают, причем мы не знаем, что из них первично. Можно заметить столбец с цифрами после указания прав на объекты, он показывает сколько ссылок жестких есть на данный inode. Создадим еще одну жесткую ссылку 

`ln file.txt hard1.txt`

### . Теперь если сделать вывод 

`ls –li`

### , то мы увидим цифру 3. Почему так происходит? Удалением файла у нас по умолчанию является действие, которое обнуляет количество всех жестких ссылок. Если мы удалим файл исходный 

`file.txt`

### . и посмотрим вывод то мы увидим, что если есть мягкие ссылки, то они прекратят работать, а файлы 

`hard.txt`

###  и 

`hard1.txt`

###  остались.

[![file://e:/Temp/app/.SBYMW1/9.png](file://e:/Temp/app/.SBYMW1/9.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/9.png)

### Более того, если обратиться к этим жестким ссылкам, например, с помощью утилиты просмотра 

`   ### cat hard.txt   `

### , то мы увидим текст, который был у нас изначально в файле.

[![file://e:/Temp/app/.SBYMW1/10.png](file://e:/Temp/app/.SBYMW1/10.png)](https://wiki.merionet.ru/images/myagkie-i-zhestkie-ssylki-v-linux/10.png)

### Это происходит потому, что сам файл — это некоторое пространство занятое на диске, а имя файла и путь к нему – это и есть жесткая ссылка. Поэтому любой файл это есть жесткая ссылка на место на диске. Мы можем создать к нашему inode сколько угодно ссылок и пока мы их всех не удалим наш файл будет на месте.

# Основы Linux от основателя Gentoo. Часть 1 (3/4): Ссылки, а также удаление файлов и директорий

[https://habr.com/ru/post/99653/](https://habr.com/ru/post/99653/)

### Жесткие ссылки

### Мы уже упоминали термин «ссылка», когда рассказывали о взаимоотношениях между директориями (их именами) и инодами (индексным номерами, лежащими в основе файловой системы, которых мы не замечаем). Вообще в Linux существует два типа ссылок. Тип, о котором мы уже говорили ранее, называется «жесткие ссылки». Каждый инод может иметь произвольное число жестких ссылок. Когда уничтожается последняя жесткая ссылка, и не одна программа не держит файл открытым, то Linux автоматически удаляет его. Новые жесткие ссылки можно создать воспользовавшись командой ln:

`$` **`cd /tmp`**

`$` **`touch firstlink`**

`$` **`ln firstlink secondlink`**

`$` **`ls -i firstlink secondlink`**

`15782 firstlink 15782 secondlink`

### Как видите, жесткие ссылки работают на уровне инодов, для указания конкретного файла. В Linux системах, для жестких ссылок есть несколько ограничений. В частности, можно создавать жесткие ссылки только на файлы, не на директории. Да-да, именно так; хотя "." и ".." являются созданными системой жесткими ссылками на директории, вам (даже от имени пользователя «root») не разрешается создавать любые свои собственные. Второе ограничение жестких ссылок состоит в том, что нельзя связать ими несколько файловых систем. Это значит, что у вас не получится создать жесткую ссылку с 

_

### /usr/bin/bash

_

###  на 

_

### /bin/bash

_

###  и если ваши директории 

_

### /

_

###  и 

_

### /usr

_

###  находятся в разных файловых системах (разделах — прим. пер.).

### Символьные ссылки

### В практике, символьные ссылки (или символические, иногда «симлинки» — от англ.) используются гораздо чаще, чем жесткие. Симлинки — это файлы особого типа, которые ссылаются на другие файлы по имени, а не прямо по номеру инода. Они не спасают файлы от удаления; если файл, на который указывает ссылка, исчезает, то симлинк перестает работать, ломается.

### Символические ссылки можно создать передав для ln опцию -s.

`$` **`ln -s secondlink thirdlink`**

`$` **`ls -l firstlink secondlink thirdlink`**

`-rw-rw-r-- 2 agriffis agriffis 0 Dec 31 19:08 firstlink`

`-rw-rw-r-- 2 agriffis agriffis 0 Dec 31 19:08 secondlink`

`lrwxrwxrwx 1 agriffis agriffis 10 Dec 31 19:39 thirdlink -> secondlink`

### В выводе ls -l символьные ссылки можно отличить тремя способами. Во-первых, обратите внимание на символ l в первой колонке. Во-вторых, размер символической ссылки равен количеству символов в ней (

_

### secondlink

_

###  в нашем случае). В-третьих, последняя колонка в выводе показывает куда ведет ссылка с помощью интуитивного обозначения "->".

### Симлинки детально

### Символические ссылки в целом более гибкие, чем жесткие. Вы можете создавать символьные ссылки на любой объект файловой системы, включая директории. И благодаря тому, что их реализация основана на путях (не инодах), можно совершенно свободно создать символьную ссылку указывающую на объект другой файловой системы. Однако, сей факт также делает их сложными в понимании.

### Предположим, что мы хотим создать ссылку в 

_

### /tmp

_

### , которая указывает на 

_

### /usr/local/bin

_

### . Нам следует набрать:

`$` **`ln -s /usr/local/bin bin1`**

`$` **`ls -l bin1`**

`lrwxrwxrwx 1 root root 14 Jan 1 15:42 bin1 -> /usr/local/bin`

### Либо, альтернативный вариант:

`$` **`ln -s ../usr/local/bin bin2`**

`$` **`ls -l bin2`**

`lrwxrwxrwx 1 root root 16 Jan 1 15:43 bin2 -> ../usr/local/bin`

### Как вы видите, обе символические ссылки указывают на одну директорию. Однако, если наша вторая символьная ссылка когда-нибудь будет перемещена в другую директорию, то она может «поломаться» из-за относительности пути:

`$` **`ls -l bin2`**

`lrwxrwxrwx 1 root root 16 Jan 1 15:43 bin2 -> ../usr/local/bin`

`$` **`mkdir mynewdir`**

`$` **`mv bin2 mynewdir`**

`$` **`cd mynewdir`**

`$` **`cd bin2`**

`bash: cd: bin2: No such file or directory`

### Потому, что директории 

_

### /tmp/usr/local/bin

_

###  не существует, мы больше не можем переместиться в 

_

### bin2

_

### ; другими словами, 

_

### bin2

_

###  сейчас сломана.

### По этой причине, избегать создания ссылок с относительной информацией о пути, иногда будет хорошей идеей. Тем не менее, существует множество случаев, где относительные символические ссылки крайне удобны. Рассмотрим пример в котором мы хотим создать альтернативное имя для программы в 

_

### /usr/bin

_

### :

`#` **`ls -l /usr/bin/keychain`**

`-rwxr-xr-x 1 root root 10150 Dec 12 20:09 /usr/bin/keychain`

### От имени суперпользователя мы хотим короткий синоним для 

_

### keychain

_

### , такой, как 

_

### kc

_

### . В этом примере у нас есть root-доступ, о чем свидетельствует измененное на "#" приветствие bash. Нам нужен root-доступ потому, что обычные пользователи не имеют прав создавать файлы в 

_

### /usr/bin

_

### . От имени суперпользователя мы можем создать альтернативное имя для 

_

### keychain

_

###  следующим образом:

`#` **`cd /usr/bin`**

`#` **`ln -s /usr/bin/keychain kc`**

`#` **`ls -l keychain`**

`-rwxr-xr-x 1 root root 10150 Dec 12 20:09 /usr/bin/keychain`

`#` **`ls -l kc`**

`lrwxrwxrwx 1 root root 17 Mar 27 17:44 kc -> /usr/bin/keychain`

### В этом примере мы создали символьную ссылку под названием kc, которая указывает на файл 

_

### /usr/bin/keychain

_

### .

### Пока это решение будет работать, но создаст проблему, если мы решим переместить оба файла, 

_

### /usr/bin/keychain

_

###  и 

_

### /usr/bin/kc

_

###  в 

_

### /usr/local/bin

_

### :

`#` **`mv /usr/bin/keychain /usr/bin/kc /usr/local/bin`**

`#` **`ls -l /usr/local/bin/keychain`**

`-rwxr-xr-x 1 root root 10150 Dec 12 20:09 /usr/local/bin/keychain`

`#` **`ls -l /usr/local/bin/kc`**

`lrwxrwxrwx 1 root root 17 Mar 27 17:44 kc -> /usr/bin/keychain`

### Поскольку мы использовали абсолютный путь для символической ссылки 

_

### kc

_

### , то она все еще ссылается на 

_

### /usr/bin/keychain

_

### , которого не существует с тех пор как мы переместили 

_

### /usr/bin/keychain

_

###  в 

_

### /usr/local/bin

_

### .

### Это привело к тому, что симлинк kc сейчас не работает. Как относительные, так и абсолютные пути в символьных ссылках имеют свои достоинства, и, в зависимости от вашей задачи, нужно использовать соответствующий тип пути. Часто, и относительный, и абсолютный путь, будут работать одинаково хорошо. Пример ниже будет работать, даже после перемещения обоих файлов:

`#` **`cd /usr/bin`**

`#` **`ln -s keychain kc`**

`#` **`ls -l kc`**

`lrwxrwxrwx 1 root root 8 Jan 5 12:40 kc -> keychain`

`#` **`mv keychain kc /usr/local/bin`**

`#` **`ls -l /usr/local/bin/keychain`**

`-rwxr-xr-x 1 root root 10150 Dec 12 20:09 /usr/local/bin/keychain`

`#` **`ls -l /usr/local/bin/kc`**

`lrwxrwxrwx 1 root root 17 Mar 27 17:44 kc -> keychain`

### Теперь, мы можем запустить программу 

_

### keychain

_

###  набрав 

_

### /usr/local/bin/kc

_

### . 

_

### /usr/local/bin/kc

_

###  указывает на программу 

_

### keychain

_

###  в той же директории, где находится 

_

### kc

_

### .

### rm

### Итак, мы знаем как использовать cp, mv и ln, настало время узнать о том, как можно удалять объекты из файловой системы. Обычно это делается с помощью команды rm. Чтобы удалить файлы, просто укажите их в командной строке:

`$` **`cd /tmp`**

`$` **`touch file1 file2`**

`$` **`ls -l file1 file2`**

`-rw-r--r-- 1 root root 0 Jan 1 16:41 file1`

`-rw-r--r-- 1 root root 0 Jan 1 16:41 file2`

`$` **`rm file1 file2`**

`$` **`ls -l file1 file2`**

`ls: file1: No such file or directory`

`ls: file2: No such file or directory`

### Имейте ввиду, что под Linux, однажды удаленный файл, обычно исчезает на века. Поэтому многие начинающие системные администраторы используют опцию -i, когда удаляют файлы. Опция -i сообщает rm удалять файлы в интерактивном режиме — это значит спрашивать перед удалением любого файла. Например:

`$` **`rm -i file1 file2`**

``rm: remove regular empty file `file1'? y``

``rm: remove regular empty file `file2'? y``

### В примере выше команда rm запрашивает подтверждение на удаление каждого из указанных файлов. В случае согласия, я должен был вводить «y» и нажать enter, дважды. Если бы я ввел «n», то файл бы остался цел. Или, если я сделал что-нибудь не так, я мог бы нажать Control-C и сбросить выполнение команды rm -i целиком — всяко до того, как это могло нанести какой-нибудь ущерб моей системе.

### Если вы все еще учитесь пользоваться командой rm, то может быть полезным добавить при помощи вашего любимого текстового редактора следующую строку в ваш файл 

_

### ~/.bashrc

_

### , и затем выйти (logout) и войти (login) в систему вновь. После этого, всякий раз, когда вы наберете rm, оболочка bash преобразует ее автоматически в команду rm -i. Таким образом, rm будет всегда работать в интерактивном режиме:

**`alias rm="rm -i"`**

### rmdir

### Для удаления директорий у вас имеется два варианта. Вы можете удалить все объекты внутри директории и затем воспользоваться rmdir для удаления самой директории:

`$` **`mkdir mydir`**

`$` **`touch mydir/file1`**

`$` **`rm mydir/file1`**

`$` **`rmdir mydir`**

### Этот метод широко известен под названием «способ удаления директорий для лохов». Все реальные пацаны и админы-гуру съевшие 

### пользователя

###  собаку на этом деле, используют гораздо более удобную команду rm -rf, описанную далее.

### Самый лучший способ удалить директорию состоит в использовании опций «рекурсивного принуждения» (recursive force) команды rm, чтобы приказать ей удалять указанную директорию, также как и объекты содержащиеся внутри:

`$` **`rm -rf mydir`**

### Обычно, rm -rf является наиболее предпочтительным методом для удаления древа директорий. Будьте очень осторожны, когда пользуетесь rm -rf, так как ее мощь может быть использована по обе стороны: добра и зла. =)

# СИМВОЛИЧЕСКИЕ И ЖЕСТКИЕ ССЫЛКИ LINUX

[https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux](https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux)

### Символические и жесткие ссылки - это особенность файловой системы Linux, которая позволяет размещать один и тот же файл в нескольких директориях. Это очень похоже на ярлыки в Windows, так как файл на самом деле остается там же где и был, но вы можете на него сослаться из любого другого места.

[![file://e:/Temp/app/.SBYMW1/11.png](file://e:/Temp/app/.SBYMW1/11.png)](https://juqu1aesh2.semmi.ru/storage/28/xow4Sheeyain4sh.jpg)

### В Linux существует два типа ссылок на файлы. Это символические и жесткие ссылки Linux. Они очень сильно отличаются и каждый тип имеет очень важное значение. В этой небольшой статье мы рассмотрим чем же отличаются эти ссылки, зачем они нужны, а также как создавать ссылки на файлы в Linux.

Содержание статьи:

• [Символические ссылки](https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux#%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8)

• [Жесткие ссылки](https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux#%D0%96%D0%B5%D1%81%D1%82%D0%BA%D0%B8%D0%B5_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8)

• [Использование ссылок в Linux](https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA_%D0%B2_Linux)◇ [Создание символических ссылок](https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85_%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA)

◇ [Создание жестких ссылок](https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B6%D0%B5%D1%81%D1%82%D0%BA%D0%B8%D1%85_%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA)

• [Выводы](https://losst.ru/simvolicheskie-i-zhestkie-ssylki-linux#%D0%92%D1%8B%D0%B2%D0%BE%D0%B4%D1%8B)

## СИМВОЛИЧЕСКИЕ ССЫЛКИ

### Символические ссылки более всего похожи на обычные ярлыки. Они содержат адрес нужного файла в вашей файловой системе. Когда вы пытаетесь открыть такую ссылку, то открывается целевой файл или папка. Главное ее отличие от жестких ссылок в том, что при удалении целевого файла ссылка останется, но она будет указывать в никуда, поскольку файла на самом деле больше нет.

### Вот основные особенности символических ссылок:

◇ Могут ссылаться на файлы и каталоги;

◇ После удаления, перемещения или переименования файла становятся недействительными;

◇ Права доступа и номер inode отличаются от исходного файла;

◇ При изменении прав доступа для исходного файла, права на ссылку останутся неизменными;

◇ Можно ссылаться на другие разделы диска;

◇ Содержат только имя файла, а не его содержимое.

### Теперь давайте рассмотрим жесткие ссылки.

## ЖЕСТКИЕ ССЫЛКИ

### Этот тип ссылок реализован на более низком уровне файловой системы. Файл размещен только в определенном месте жесткого диска. Но на это место могут ссылаться несколько ссылок из файловой системы. Каждая из ссылок - это отдельный файл, но ведут они к одному участку жесткого диска. Файл можно перемещать между каталогами, и все ссылки останутся рабочими, поскольку для них неважно имя. Рассмотрим особенности:

◇ Работают только в пределах одной файловой системы;

◇ Нельзя ссылаться на каталоги;

◇ Имеют ту же информацию inode и набор разрешений что и у исходного файла;

◇ Разрешения на ссылку изменяться при изменении разрешений файла;

◇ Можно перемещать и переименовывать и даже удалять файл без вреда ссылке.

## ИСПОЛЬЗОВАНИЕ ССЫЛОК В LINUX

### Теоретические отличия вы знаете, но осталось закрепить все это на практике, поэтому давайте приведем несколько примеров работы со ссылками в Linux. Для создания символических ссылок существует утилита ln. Ее синтаксис очень прост:

### **$ ln** 

**

### опции

** **

### файл_источник

** **

### файл_ссылки

**

### Рассмотрим опции утилиты:

◇ **-d** - разрешить создавать жесткие ссылки для директорий суперпользователю;

◇ **-f** - удалять существующие ссылки;

◇ **-i** - спрашивать нужно ли удалять существующие ссылки;

◇ **-P** - создать жесткую ссылку;

◇ **-r** - создать символическую ссылку с относительным путем к файлу;

◇ **-s** - создать символическую ссылку.

### СОЗДАНИЕ СИМВОЛИЧЕСКИХ ССЫЛОК

### Сначала создайте папку test и перейдите в нее:

###  `mkdir test && cd test`

[![file://e:/Temp/app/.SBYMW1/12.png](file://e:/Temp/app/.SBYMW1/12.png)](https://losst.ru/wp-content/uploads/2016/12/link-1024x633.png)

### Затем создайте файл с именем source с каким-либо текстом:

###  `echo "текст текст текст текст" > source`

### `$ cat source`

[![file://e:/Temp/app/.SBYMW1/13.png](file://e:/Temp/app/.SBYMW1/13.png)](https://losst.ru/wp-content/uploads/2016/12/link1.png)

### Файл готов, дальше создадим символическую ссылку Linux, для этого используется команда ln с опцией -s:

###  `ln -s source softlink`

[![file://e:/Temp/app/.SBYMW1/14.png](file://e:/Temp/app/.SBYMW1/14.png)](https://losst.ru/wp-content/uploads/2016/12/link2-1024x614.png)

### Попробуем посмотреть содержимое файла по ссылке:

###  `cat softlink`

[![file://e:/Temp/app/.SBYMW1/15.png](file://e:/Temp/app/.SBYMW1/15.png)](https://juqu1aesh2.semmi.ru/storage/24/eit6Lee4Besieno.png)

[![file://e:/Temp/app/.SBYMW1/16.png](file://e:/Temp/app/.SBYMW1/16.png)](https://losst.ru/wp-content/uploads/2016/12/link3.png)

### Как видите, нет никакой разницы между ней и исходным файлом. Но утилита ls покажет что это действительно ссылка:

###  `ls -li`

[![file://e:/Temp/app/.SBYMW1/17.png](file://e:/Temp/app/.SBYMW1/17.png)](https://losst.ru/wp-content/uploads/2016/12/link4.png)

### Несмотря на то, что содержимое одинаковое, здесь мы видим, что адрес иноды и права доступа к файлам отличаются, кроме того, явно показано что это символическая ссылка Linux.

### Теперь удалите исходный файл и посмотрите что будет:

###  `cat softlink`

[![file://e:/Temp/app/.SBYMW1/18.png](file://e:/Temp/app/.SBYMW1/18.png)](https://losst.ru/wp-content/uploads/2016/12/link6-1024x605.png)

### Вы получите ошибку, что такого файла не существует, потому что мы действительно удалили исходный файл. Если вы удалите ссылку, то исходный файл останется на месте.

### СОЗДАНИЕ ЖЕСТКИХ ССЫЛОК

### Снова создайте файл source с произвольным текстом:

###  `echo "текст текст текст текст" > source`

### `$ cat source`

[![file://e:/Temp/app/.SBYMW1/19.png](file://e:/Temp/app/.SBYMW1/19.png)](https://losst.ru/wp-content/uploads/2016/12/link7.png)

### Теперь создадим жесткую ссылку Linux. Для этого достаточно вызвать утилиту без параметров:

###  `ln source hardlink`

[![file://e:/Temp/app/.SBYMW1/20.png](file://e:/Temp/app/.SBYMW1/20.png)](https://losst.ru/wp-content/uploads/2016/12/link8-1024x602.png)

### Посмотрите содержимое файла:

###  `cat hardlink`

[![file://e:/Temp/app/.SBYMW1/21.png](file://e:/Temp/app/.SBYMW1/21.png)](https://losst.ru/wp-content/uploads/2016/12/link9.png)

### Данные те же самые, а если мы посмотрим вывод утилиты ls, то увидим что inode и права доступа тоже совпадают:

###  `ls -li`

[![file://e:/Temp/app/.SBYMW1/22.png](file://e:/Temp/app/.SBYMW1/22.png)](https://losst.ru/wp-content/uploads/2016/12/link10.png)

### Если для одного из файлов поменять разрешения, то они изменяться и у другого. Теперь удалите исходный файл:

###  `rm source`

### Затем посмотрите содержимое:

###  `cat hardlink`

[![file://e:/Temp/app/.SBYMW1/23.png](file://e:/Temp/app/.SBYMW1/23.png)](https://losst.ru/wp-content/uploads/2016/12/link11-1024x612.png)

### Как видите, ничего не произошло и ссылка по-прежнему указывает на нужный участок диска, это главное отличие жесткой ссылки от символической. Мы можем сделать вывод, что жесткая ссылка linux это обычный файл. Каждый файл имеет как минимум одну ссылку, но для некоторых мы можем создать несколько ссылок.

## ВЫВОДЫ

### Это все, что вам было необходимо знать про символические и жесткие ссылки linux. Надеюсь, вы получили общее представление об этих возможностях файловой системы и сможете использовать их для решения своих задач.

[https://tavportal.ru/blog/linux/chto-takoe-simvolicheskie-i-zhestkie-ssyilki-v-linux-(linuks](https://tavportal.ru/blog/linux/chto-takoe-simvolicheskie-i-zhestkie-ssyilki-v-linux-(linuks)[)](https://tavportal.ru/blog/linux/chto-takoe-simvolicheskie-i-zhestkie-ssyilki-v-linux-(linuks))

### Практическая работа по символическим ссылкам:

cd # в домашний каталог

mkdir -p standards/{civil,mechanical} # создать структуру необходимых каталогов

cd standards/civil # в каталог строительных стандартов

touch document1.txt # создаем новый файл со стандартом

echo "some text" > document1.txt # содержимое...

man ln # для выхода нажать "q"; это справка по "ln", почитайте

cd ../mechanical/ # в каталог машиностроительных стандартов

ln -s ../civil/document1.txt document1.txt # создаем симв. ссылку

# с таким же именем

ls -l # посмотрим, что вышло

pwd # где мы находимся

file document1.txt # что за файл "document.txt" в текущем каталоге?

cat document1.txt # просмотр исходного файла по ссылке

echo "additional text" >> document1.txt # редактирование файла по ссылке

cat ../civil/document1.txt # видно, что оригинал изменился

rm -f ../civil/document1.txt # удаление оригинального документа

ls -l # а ссылка осталась

cat document1.txt # ошибка, т.к. ссылка "висячая" (ссылается на

# несуществующий файл)

echo "new text" >> document1.txt # запись в файл по ссылке;

# будет создан новый файл-оригинал -

# ~/standards/civil/document1.txt

cat document1.txt # переход по ссылке, видно что файл-оригинал существует

cp document1.txt ../document1.txt # копируем ссылку в каталог "standards"

cd ../ # переход в каталог "standards"

ls -l # видно, что скопирован файл-оригинал

file document1.txt # ...не ссылка, а настоящий файл

### Практическая работа по жестким ссылкам:

# в той же иерархии каталогов, что была создана в работе по симв. ссылкам

# /home/joe/standards

cd civil

echo "123456" > myfile

ls -i myfile # уникальный номер созданного файла

ls -l myfile # число 1 указывает, что у файла одна жесткая

# ссылка

ln myfile ../mechanical/myfile # создаем жесткую ссылку

# пусть имена файлов будут одинаковые

cd ../mechanical/

ls -i myfile # уникальные номера совпадают

ls -l myfile # видим, что у файла уже 2 жестких ссылки

file myfile # при чем файловая система видет напрямую файл

# а не ссылку (как при симв. ссылке)

cp myfile ../myfile # скопируем в каталог standards

cd ../

ls -il myfile # у скопированного файла уже другой уникальный

# номер, и счетчик ссылок – 1, т.е. это новый

# файл а не жесткая ссылка на созданный нами

rm -f civil/myfile # удалим созданный нами в самом начале файл

cd mechanical/

ls -il myfile # количество ссылок стало 1, но номер тот же

#### Выводы

1. Символические ссылки удобно использовать, когда файл-оригинал будет находится по неизменному пути (не будет переноситься в дальнейшем) и его имя будет оставаться также неизменным. Нормально будет сделать символическую ссылку для запуска приложения /usr/bin/local/myapp из каталога рабочего стола, скажем /home/joe/Desktop. Таким образом из графической оболочки (например, KDE) можно будет быстро, одним щелчком мыши, запустить приложение myapp. Такая ссылка будет скорее всего всегда актуальная, т.к. в /usr/bin редко что переименовывается. Также немаловажно, что при обновлении программы myapp (скажем, ее удалят и на ее место скопируют новую копию) – ссылка останется актуальной. Наиболее часто я использую символические ссылки именно в таком ключе – создаю ссылки для приложений на рабочий стол

2. Жесткие ссылки удобно использовать при другого рода динамике системы. Например, мы администрируем сервер электронной библиотеки. Есть книга, относящаяся к математике и музыке (назовем ее «Математика и музыка»). При чем оговоримся, что эта книга никогда не будет заменена на более новую с таким же именем файла. Вполне резонно будет сделать жесткие ссылки так, чтобы книга находилась и в разделе «Математика», и в разделе «Музыка»

3. Чаще применяют символические ссылки; это связано с динамикой изменения системы. Например, при обновлениях старые файлы удаляются, создаются новые, с теми же именами, и жесткие ссылки не обеспечат правильного поведения

#### Примеры применения ссылок

• есть разные оболочки (интерпретаторы команд консоли) – bash, dash и т.д. Но всегда есть файл /bin/sh – это как раз символическая ссылка на конкретную программу (выполните команду «file /bin/sh», чтобы убедится в этом). Чтобы изменить реализацию интерпретатора команд в системе – достаточно изменить символическую ссылку sh на соответствующий исполняемый файл

• когда вы выполняете команду «ls -la» и видите каталоги «..» и «.» — это жесткие ссылки, создаваемые системой для предыдущего и текущего каталога соответственно. Сами вы не можете создавать жесткие ссылки на каталоги, а вот система может

• допустим, у вас есть фильм «Into the wild» и саундтреки (OST) к нему. Очевидно, саундтреки относятся и к данному фильму, и к категории «Музыка». Мы хотим видеть эти саундтреки и в каталоге фильма, и в каталоге музыки. Но если положить саундтреки и туда, и туда — это займет в 2 раза больше места на диске, и если вы захотите дополнить или изменить файлы саундтреков — придется делать это в двух местах. Выход из этой ситуации — положить саундтреки в каталог «Музыка» (очевидно, что к этой категории они относятся больше, чем к фильмам) и сделать на весь каталог саундтреков символическую ссылку, которая будет находиться в каталоге с фильмом:~/Data/Video/Movies/Into the wild/OST -> ~/Data/Music/OST/Into the wild

• также есть замечательный инструмент, к ссылкам отношения не имеющий, но похожий по своей работе: «mount -o bind». Я применял эту команду для выкладывания на свой ftp-сервер музыки, фильмов и т.д. (чтобы выложить файлы на ftp-сервер, необходимо было поместить их в папку /home/ftp/pub, что и делала эта команда без необходимости копировать данные)

#### Список использованной литературы

1. [http://habrahabr.ru/blogs/linux/99653/](http://habrahabr.ru/blogs/linux/99653/)

2. Нейл Мэтью, Ричард Стоунс. Основы программирования в Linux, 4-е издание. Глава 3