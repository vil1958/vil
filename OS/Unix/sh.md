[http://forum.ru-board.com/topic.cgi?forum=65&bm=1&topic=2790&start=2800#lt](http://forum.ru-board.com/topic.cgi?forum=65&bm=1&topic=2790&start=2800#lt)

[https://ru.wikibooks.org/wiki/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2_%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_UNIX/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0_UNIX](https://ru.wikibooks.org/wiki/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2_%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_UNIX/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0_UNIX)

Крупнейшая база полезных однострочников на командной оболочке с ранжированием на основе пользовательского голосования.

[https://www.commandlinefu.com/commands/browse/sort-by-votes](https://www.commandlinefu.com/commands/browse/sort-by-votes)

Аналогично, но поменьше и формат записей более свободный, поэтому встречаются и однострочники, и развернутые скрипты, и просто советы.

[http://www.shell-fu.org/lister.php?top](http://www.shell-fu.org/lister.php?top)

Почти исчерпывающий список решений для тех случаев, когда sed незаменим. Более сложные скрипты с sed.sf.net — только для тех, кто знает толк... :)

[http://sed.sourceforge.net/sed1line.txt](http://sed.sourceforge.net/sed1line.txt)

[https://abclinux.org/shell-skripty-dlya-ubuntu-linux](https://abclinux.org/shell-skripty-dlya-ubuntu-linux)

# Введение в администрирование UNIX/Командная строка UNIX
https://ru.wikibooks.org/wiki/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2_%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_UNIX/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0_UNIX


# Shell скрипты для Ubuntu Linux

• [Юрий Герук](https://abclinux.org/index/8-590)

• 2016-12-30

• [Инструкции](https://abclinux.org/manual-linux)

• 4852

• [3](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#comments)

• 10 минут

**Содержание**

[1. Небольшая подборка полезных Shell скриптов для использования в Linux](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Небольшая-подборка-полезных-Shell-скриптов-для-использования-в-Linux)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Небольшая-подборка-полезных-Shell-скриптов-для-использования-в-Linux)[2. Начнем с простых примеров](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Начнем-с-простых-примеров)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Начнем-с-простых-примеров)[3. Сводка погоды в консоли](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Сводка-погоды-в-консоли)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Сводка-погоды-в-консоли)[4. Для рабочего стола](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Для-рабочего-стола)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Для-рабочего-стола)[5. Ищем в Google из командной строки](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Ищем-в-Google-из-командной-строки)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Ищем-в-Google-из-командной-строки)[6. Вывод](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Вывод)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Вывод)

Ошибка в тексте? Выделите ее мышкой! И нажмите: CTRL+Enter, [сообщите об этом](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#erorr), автор постарается в краткие сроки обновить / исправить материал.

#### Примеры подстановки и замены в переменной:
```
name="srv.domain.ru";
newname="${name//.}";
echo $newname;
 
name1="srv.domain.ru";
newname1="${name1//./_}";
echo $newname1;
 
name2="$(date +"%Y_%m_%d_%H_%M")";
newname2="${name2//_}";
echo $newname2;

name=t.e.s.t
echo "${name//.}"
test
echo "${name//./_}"
t_e_s_t
 
name=t.e.s.t
echo $name | tr -d \.
test
echo $name | sed 's/\.//g'
test
echo $name | sed 's/\.//g'
test
echo $name | sed 's/\./_/g'
t_e_s_t
```


### Небольшая подборка полезных Shell скриптов для использования в Linux

Консоль Linux - это тот инструмент который позволяет выполнять такие манипуляции, которые не позволяет творить командная строка в Windows, консоль Linux, это визитная карточка UNIX. Сегодня материал не о том как писать скрипты, нет, я вас не буду учить как, что и для чего. Мы рассмотрим небольшую подборку полезных скриптов, которые вы сможешь применять ежедневно для решения задач разного рода, например посмотреть погоду на несколько дней вперед, скрипты для веб-сервера в одну строку, написание бота для твиттера и скриптом для автоматического запуска любого торрент-клиента.

[![file://e:/Temp/app/.SBYMW1/1.png](file://e:/Temp/app/.SBYMW1/1.png)](https://abclinux.org/picte/other/bash-shell.png)

Этот материал написан, не чтобы вы занимались шаманизмом, ни в коем случае я вас не призываю сидеть в консоли и печатать сотни символов, чтобы выполнить некоторые действия, которые вы можете выполнить в графическом интерфейсе лишь наведя мышку на необходимый вам элемент. Но есть одно но, не всегда графический интерфейс является лучшим решением, часто для решения многих задач консоль и скрипты справляются с поставленной задачей намного лучше чем приложения с графическим интерфейсом, в связи с чем о скриптах забывать нельзя так как много рутинной работы они решают лучше графических инструментов. Стоит так же добавить, что любая DE позвoляет вам создать для ваших скриптов иконку, нажав на которую, вы сможете их легко запустить не открывая консоль.

## Начнем с простых примеров

Команда ниже покажет вам ваш внешний IP - это идеальный вариант, если в Сеть вы входите используя роутер. Эта команда обращается к серверу ifconfig.co, который возвращает IP одной строкой без лишней писанины которая вам не нужна.

curl ifconfig.co

Да, это не скрипт, это небольшая команда, но если вы хотите превратить эту команду в скрипт, вам достаточно поместить ее в текстовый файл, в итоге у нас получится небольшой bash скрипт:

#!/bin/bash

curl ifconfig.co

Сохраняeм скрипт в каталог ~/bin и даем права на исполнение:

chmod +x ~/bin/yourip.sh

Почти готово, вы можно исполнить скрипт из командной строки используя команду yourip.sh.

C айпи закончили, посмотрим погоду с консоли.

## Сводка погоды в консоли

#!/bin/sh

curl -4 wttr.in/Kiev

Этот скрипт позволяет получить сводку погоды на четыре дня, в данном случае погода для города Киев.

[![file://e:/Temp/app/.SBYMW1/2.png](file://e:/Temp/app/.SBYMW1/2.png)](https://abclinux.org/post1/other/pogoda-kiev.jpeg)

#!/bin/sh

dig +short txt $1.wp.dg.cx

Выше вы видите пример, как можно получить краткое описание чего-нибудь в Википедии, в нашем случае мы используем DNS-запрос вместо обращения к веб-серверу. Веб-сервер через консоль также очень легко создать:

#!/bin/sh

while ( nc -l 80 < file.html > : ) ; do : ; done

Скрипт выше основан на утилите netcat (nc), часто ее называют швейцарским армейским ножом, так как позволяет вытворять много трюков для сетевых опeраций. Скрипт простой он запускает цикл, который выполняет команду nc, та уже слушает 80-й порт и в ответ на запрос отдает _file.html_, отправляя переданный запрос в никуда (символ означает noop, то есть пустую операцию).

Используя простые скрипты и команд, вы можете слушать интернет-радио:

#!/bin/sh

mpv --volume=50 -playlist ~/16bit.fm_128.m3u

Конечно, до этого вам нужно скачать плей-лист радио в формате M3U с сайта радиостанции. Если зaпустить MPlayer используя аргумент _—input-ipc-server=/tmp/mpvsocket_, им можно будет управлять, записывая команды в файл. Например, настроить громкость:

echo 'volume +10' | socat - /tmp/mpvsocket

Создаем два скрипта: первый для запуска, а другой для остановки радио (в котором мы пропишем строку killall mpv), далее повесь на рабочий стол совместно настроив горячие клавиши DE для управления воспроизведением. И готово, вы имеете плеер с помощью которого вы можете заускать интернет-радио.

Увлеклись сетевыми операциями, перейдем к локальным.

#!/bin/sh

tar -czf "../${PWD##*/}.tar.gz" .

Это скрипт создает архив tar.gz для текущего кaталога. Особое внимание нужно уделить конструкции ${PWD##*/}, которая бeрет весь путь до текущего каталога (переменная $PWD) далее удаляет первую чаcть до последнего слеша, в итоге остается лишь имя каталoга и к нему добавляется расширение tar.gz. Если вы хотите узнать больше информации по подобных конструкциях, вы можете прочитать выполнив в консоли команду man bash.

#!/bin/sh

while true; do

inotifywait -r -e MODIFY КАТАЛОГ && ТВОЯ_КОМАНДА

done

Скрипт выше запускает команду в ответ на изменение файлов в каталоге. Вы ее можете применять для разных целей, как пример для автоматического включения плеера при сохранении MP3. Или же как пример выводить увeдомление на рабочий стол, используя команду notify-send:

notify-send "Файл изменен"

## Для рабочего стола

Ниже вы увидите пример скрипта, который загружает случайные обои, которые опубликованы на reddit-канале wallpaper:

#!/bin/bash

wget -O - http://www.reddit.com/r/wallpaper |\

grep -Eo 'http://i.imgur.com[^&]+jpg' |\

shuf -n 1 |\

xargs wget -O background.jpg

feh --bg-fill background.jpg

Работает все довольно просто. Используя утилиту wget скрипт загружает страницу www.reddit.com/r/wallpaper, далее передает ее grep, который уже ищет ссылки на imgur, и выбирает случайную с помощью shuf, загружает ее с помощью wget и устанавливает в качестве обоев для вашего рабочего стола, используя команду feh (это миниатюрный просмотрщик изображений, который нужно предварительно устанoвить). Вы этот скрипт можете добавить в обычный текстовый файл как я описывал выше, сохранить в формате sh, сделать исполняемым, добавить к нему иконку и запускать с рабочего стола по клику и у вас будут меняться обои.

#!/bin/sh

state=`synclient | grep TouchpadOff | cut -d '=' -f 2`

if [ $state = "1" ]; then

synclient TouchpadOff=0

else

synclient TouchpadOff=1

fi

Скрипт выше используется для включения и выключения тачпада вашего ноутбука: включает, если отключен, и наоборот. Для корректной работы в нем используется утилита synclient, которая и позволяет управлять тачпадами которые в большинстве производит Synaptics, это 90% возможно даже и более. После запуска утилита выводит много информации, так же строку TouchpadOff = 1, если он активирован, и TouchpadOff = 2, если отключен. Скрипт прочитав эти значение и в зависимости от состояния тачпада включит или отключит его.

!#/bin/bash

mpv tv:// -frames 3 -vo jpeg

mv 00000003.jpg photo.jpg

rm -f 0000*.jpg

Используя скрипт выше, вы можете создать снимок используя веб-камеру. В скрипте используется видеоплеер mpv который записывает первые три кадра, снятые камерой, в файлы JPEG формата с именами 0000000.jpg, 00000002.jpg, 00000003.jpg итд, после переименовывается третий снимок в файл photo.jpg, а остальные удаляются. Для чего используются три снимка? Они необходимы лишь для того, чтобы ваша камера успела провести инициализацию, если использовать первые два снимка, то обычно вы получите черный снимок. Бывают так же казусы с позиционированием, фото может быть перевернутым; чтобы этого избежать mpv нужно запускать с флагом -vf flip:

mpv tv:// -frames 3 -vf flip -vo jpeg

Эту же команду, вы можете использовать для создания камеры слежения, которая будет делает снимки лишь в те моменты, когда пользователь прикоснется к мыши:

#!/bin/bash

while true; do

sudo cat /dev/input/mouse0 | read -n1

mpv tv:// -frames 3 -vo jpeg

mv 00000003.jpg `date +%F-%H-%M`.jpg

rm -f 0000*.jpg

sleep 10

done

Скрипт выше использует бесконечный цикл, получая данные с устройства /dev/input/mouse0. Если данные есть, значит, мышь была сдвинута или была нажата одна из ее кнопок. После используется mpv, для создания трех снимков, третьему снимку присваивается имя текущей даты и удаляются первые два.

Если вы хотите записать полноценное видео с веб-камеры, как пример можно использовать подобный скрипт:

#!/bin/bash

mencoder tv:// -tv driver=v4l2:width=800:height=600:device=/dev/video0:fps=30:outfmt=yuy2:forceaudio:alsa:adevice=hw.2,0 -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=1800 -ffourcc xvid -oac mp3lame -lameopts cbr=128 -o video.avi

В результате вы получите файл с названием video.avi в формaте MPEG4, битрейт 1800 и аудиофайл в формате MP3 с битрейтом 128.

#!/bin/bash

ffmpeg -f x11grab -r 25 -s 1366x768 -i :0.0 screencast.mpg

Используя скрипт выше, вы можете записать полноценный скринкаст. 1366×768 - это разрешение рабочего стола, можете настроить под себя. Для создания скриншота отдельного окна, вы можете использовать команду import:

import screenshot.png

Если запустить команду выше, значок курсора вашей мыши изменится на крестик, используя который, вы сможете выделить область экрана как это вы делаете при создании скриншотов используя сторонние приложения или расширения. Если повесить эту команду на одну из горячих клавиш, вы получите практически идеальную систему для создания скриншотов, и эта комбинация не будет кушать вашу оперативную память, что значительно придает ей огромный плюс.

Вы также можете настроить внешний монитор используя консоль:

#!/bin/sh

if [ -z "$1" ]; then

exit

fi

if [ $1 == "off" ]; then

xrandr --output VGA-0 --off

xrandr -s 0

else if [ $1 == "on"]; then

xrandr --output LVDS --auto --primary --output VGA-0 --auto --left-of LVDS

xrandr --newmode "1920x1080" 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync

xrandr --addmode VGA-0 1920x1080

xrandr --output VGA-0 --mode 1920x1080

fi

xrandr --dpi 96

Этот скрипт основывается на том, что основной монитор имеет имя LVDS, а внешний - VGA-0. Это стандартная ситуация для всех ноутбуков; если вы не уверены, можно проверить выполнив команду xrandr: при передаче скрипту аргумента _off_ он отключает внешний монитор, аргумент _on_, в свою очередь, включает его, располагая по левую сторону от основного (аргумент _—left-of LVDS_ в первoй команде). После скрипт создает новую конфигурацию для монитоpа с разрешением 1920 x 1080 и активирует его. И под конец, скрипт устанавливает дефолтное знaчение DPI - так как при подключении монитора с другим разpешением оно часто слетает.

В большинстве случаев команды _xrandr —newmode …_ и _xrandr —addmode …_ не нужны, так как Xorg получит конфигурацию монитора и разрешение с помощью EDID. Иногда, однако, этого не происходит, и строку конфигурации, указываемую после аргумента _—newmode_, приходится генерировать самостоятельно с помощью инструмента cvt:

cvt 1920 1080

Используя инструмент cvt, можно сгенериpовать нестандартны разрешения, которые не поддерживаются монитором по умолчанию.

## Ищем в Google из командной строки

Вернемся снова к сетевым сервисам. Как получить первый 10 результатов поиска в Google? Смотрим скрипт ниже:

#!/bin/bash

Q="$@"

URL='https://www.google.de/search?tbs=li:1&q='

AGENT="Mozilla/4.0"

stream=$(curl -A "$AGENT" -skLm 10 "${GOOG_URL}${Q//\ /+}" | grep -oP '\/url\?q=.+?&amp' | sed 's|/url?q=||; s|&amp||')

echo -e "${stream//\%/\x}"

Этот скрипт отправляет запрос к Google с помощью curl, заменяет пробелы в поисковой строке на плюсы. После в ответном HTML выскакивают ссылки

Пример с сервисом YouTube:

#!/bin/bash

mpv -fs -quiet `youtube-dl -g "$1"` Скрипт с примера выше проигрывает видео с указанным в аргументе ID с помощью плеера mpv. Заранее нужно установить youtube-dl.

Несколько примеров работы с Twitter. Ниже вы увидите скрипт полноценного бота, который на входе принимает команду, выполняет ее с помощью командного интерпретатора и отправляет результат указанному юзеру.

#!/bin/bash

USER="Ваш Ник"

while true; do

CMD=`echo "/dma +1" | ttytter -script | sed 's/\[.*\]\ //'

if [ $CMD != $OLD_CMD ]; then

REPL=`$CMD`

echo "/dm $USER ${REPL:0:140}" | ttytter -script

CMD = $OLD_COMD

fi

sleep 60

done В скрипте используется консольный клиент ttytter, читая с цикла последнее значение direct message, после происходит проверка, не была ли эта команда выполнена, если нет, выполняет ее и отправляет указанному юзеру с переменной USER обрезая до 140 символов.

Чтобы все работало, вам нужно установить утилиту ttytter, запустить ее, после скопировать сгенерированную ссылку с консоли и вставить в адресную строку браузера, пройти подтверждение, согласиться, после получите ключ аутентификации, скопируйте и вставьте его в консоли в ttytter. Конечно, перед всем этим желательно добавить отдельного юзера и залогиниться под его учеткой.

Использовать твиттер можно не лишь в целях создания бота, но и для мониторинга машины. Скрипт ниже отправляет в ленту сообщение с информацией о состоянии машины (имя хоста, uptime, нагрузка, свободная память и нагрузка на CPU):

#!/bin/bash

HOST=`hostname -s`

UP=`uptime | cut -d" " -f4,5 | cut -d"," -f1`

LOAD=`uptime | cut -d":" -f5,6`

MEM=`ps aux | awk '{ sum += $4 }; END { print sum }'`

CPU=`ps aux | awk '{ sum += $3 }; END { print sum }'`

tweet="Host: ${HOST}, uptime: ${UP}, cpu: ${CPU}%, memory: ${MEM}%, loadavg ${LOAD}"

if [ $(echo "${tweet}" | wc -c) -gt 140 ]; then

echo "FATAL: The tweet is longer than 140 characters!"

exit 1

fi

echo $tweet | ttytter -script

Напоследок смотрим скрипт ниже, этот скрипт используется для запуска и остановки торрент-клиента пока ваш ПК простаивает:

#!/bin/bash

IDLE=600000

STOPCMD="transmission-remote -S"

STARTCMD="transmission-remote -s"

STOPPED="yes"

while true; do

if [ `xprintidle` -gt $IDLE ]; then

if [ $STOPPED = "yes" ]; then

$STARTCMD

STOPPED="no"

fi

else

if [ $STOPPED = "no" ]; then

$STOPCMD

STOPPED="yes"

fi

fi

sleep 60

done Каждую минуту скрипт уходит в бесконечный цикл и проверяет, сколько времени в миллисекундах прошло с момента, когда юзер выполнял последние действия (для этих целей используется xprintidle). Если прошло 600 000 мс (десять минут), скрипт выполняет команду, которая укaзана в переменной STARTCMD. В ином случае выполняется команда STOPCMD, но лишь в том случае, если до нее была выполнена STARTCMD. Если объяснить простым языком, вы ничего не делаете за компьютером десять минут, после  запускается STARTCMD, в нашем случае это команда которая запускает все закачки в Transmission, если нет - все закачки приостанавливаются. Не любите клиент Transmission? Используем команды для Deluge, смотрим ниже:

STOPCMD="deluge-console pause \*"

STARTCMD="deluge-console resume \*"

## Вывод

Описанное выше может показаться вам сложным или же лишним так как вместо писанины в консоли вы можете найти много утилит с графическим интерфейсом которые выполнят необходимые задачи в один клик без использования консоли. Да, соглашусь с вами, но не все доступно с графического интерфейса, часто именно консоль спасает от рутинной работы если уметь ей пользоваться. На этом пожалуй и окончим материал, если вы имеете чем поделиться(скриптами), оставляйте комментарии к материалу.

Источник: [xakep.ru](https://abclinux.org/go?https://xakep.ru/)

**Автор: Юрий Герук**

# Bash-скрипты, часть 10: практические примеры

[https://habr.com/ru/company/ruvds/blog/328346/](https://habr.com/ru/company/ruvds/blog/328346/)

============================================================

[http://forum.ru-board.com/topic.cgi?forum=65&bm=1&topic=2790&start=2860#lt](http://forum.ru-board.com/topic.cgi?forum=65&bm=1&topic=2790&start=2860#lt)

Доброго дня, помогите, есть такая строка

``for iface in `ifconfig | cut -c 1-8 | sort | uniq -u | grep -v lo | grep -v : `; do echo $iface; done``

если сетевой интерфейс имеет 8 символов "enp2s0s5" то все отлично работает, а если 6 символов "enp2s0" то не работает, как модифицировать код чтобы что бы работало и на 6 и на 8 символов?

Если стоит задача вывести список сетевых интерфейсов то я бы сделал это так
`netstat -i | sed 1,2d | grep -v lo | awk  '{print $1}'`

Условие 'grep -v :' неточное, поскольку символ ':' может включаться в имя интерфейса, например, если это алиас.

А какая задача-то решается? Если вывести имена всех сетевых интерфейсов, кроме lo, то может использовать что-то менее монструозное? Ну например:
`ifconfig | grep HW | awk '{print $1}'`

 Ну и таки да, может быть уже закопать стюардессу в виде net-tools, и использовать iproute2?

А ничего, что iproute2  сейчас как бы стандарт. Его можно везде встретить, а вот ifconfig aka net-tools уже не везде

Но на самом деле ты прав. Не нужно грепать по HW (это у меня видимо помутнение было). Универсальней для линуксов с net-tools будет примерно так:
 `ifconfig -s | grep -v 'Iface' | awk '{print $1}'`

или если парсить вывод утилит, то я согласен с теми кто ратовал за утилиту ip. Ибо ifconfig давно deprecated.
`ip -o link show | awk -F' |:' '{print $3}'`

### [Что такое командная оболочка (shell) в Linux?](https://ravesli.com/shell-v-linux/)
Оглавление:

1. [Что такое shell?](https://ravesli.com/shell-v-linux/#toc-0)
2. [Внутренние и внешние команды оболочки](https://ravesli.com/shell-v-linux/#toc-1)
3. [Как узнать какая оболочка у меня установлена?](https://ravesli.com/shell-v-linux/#toc-2)
4. [Типы командных оболочек](https://ravesli.com/shell-v-linux/#toc-3)
    - [sh (Bourne Shell)](https://ravesli.com/shell-v-linux/#toc-4)
    - [bash (Bourne-Again shell)](https://ravesli.com/shell-v-linux/#toc-5)
    - [ksh (Korn shell)](https://ravesli.com/shell-v-linux/#toc-6)
    - [csh (C shell)](https://ravesli.com/shell-v-linux/#toc-7)
    - [tcsh (TENEX C Shell)](https://ravesli.com/shell-v-linux/#toc-8)
    - [zsh (Z Shell)](https://ravesli.com/shell-v-linux/#toc-9)
5. [Резюмируем](https://ravesli.com/shell-v-linux/#toc-10)

## Что такое shell?

**Shell** (или **_«шелл»_**, **_«командная оболочка»_**) — это не только командный интерпретатор, который обеспечивает интерфейс взаимодействия между пользователем и ядром операционной системы, но и своеобразный язык программирования, в котором присутствуют такие конструкции, как операторы условного ветвления, циклы, переменные и многое другое.

Операционная система (ОС) запускает командную оболочку для каждого пользователя, когда тот входит в систему или открывает окно терминала. Первым что пользователь увидит в окне терминала, будет **приглашение оболочки** — оно, как правило, состоит из имени пользователя и имени хоста, отделенные друг от друга символом `@`, следом за ними идет путь текущей рабочей директории и один из двух символов: `$` или `#`.

Если пользователь не наделен особыми правами, то в качестве приглашения к вводу команд в терминале будет отображаться символ `$`. Если же был выполнен вход под учетной записью привилегированного (root) пользователя, то в терминале вы увидите символ `#`:

![](https://ravesli.com/wp-content/uploads/2021/03/1.png)

_Окно терминала обычного пользователя (виден символ $)_

![](https://ravesli.com/wp-content/uploads/2021/03/2.png)

_Окно терминала привилегированного (__root) пользователя (виден символ #)_

**_Примечание:_** Знак тильды (`~`) указывает на то, что мы находимся в домашнем каталоге текущего пользователя.

После приглашения, пользователь вводит различные команды в терминал, оболочка запускает программы для пользователя, а затем отображает в терминале результат их выполнения. Команды могут быть либо введены непосредственно самим пользователем, либо считаны из файла, называемого shell-скриптом или shell-программой.

Ниже представлен пример выполнения простой команды `date`, возвращающей текущую дату и время:

![](https://ravesli.com/wp-content/uploads/2021/03/3-1.png)  

## Внутренние и внешние команды оболочки

Вводимые пользователем команды делятся на два типа:

   **Внутренние** — это команды, изначально встроенные в оболочку.

   **Внешние** — это команды, которые не встроены в оболочку. По своей сути они являются скорее небольшими отдельными программами, расположенными где-то в файловой системе (обычно, в каталогах _/bin_ или _/usr/bin_).

Чтобы определить тип команды, достаточно в окне терминала ввести `type <имя_команды>`:

![](https://ravesli.com/wp-content/uploads/2021/03/5.png)

Как вы можете видеть, команды `dirs`, `pwd`, `cd` и `true` — являются внутренними командами оболочки bash. А вот команды `uname`, `id` и `whereis` — являются внешними, т.к. они ссылаются на соответствующие файлы в каталоге _/usr/bin_.

Ознакомиться с полным списком внутренних команд оболочки можно при помощи команды `help`:

![](https://ravesli.com/wp-content/uploads/2021/03/4.png)  

## Как узнать какая оболочка у меня установлена?

Если вы только начинаете свое знакомство с Linux и не меняли оболочку, то наиболее вероятно, что в вашей системе используется bash. Самый простой способ узнать, какая оболочка используется в данный момент — это обратиться к переменной окружения `SHELL`:

`echo $SHELL`

![](https://ravesli.com/wp-content/uploads/2021/03/13.png)

Кроме того, можно задействовать команду `ps –p $$`, возвращающую информацию о процессе с заданным идентификатором. В нашем случае, идентификатором оболочки являются символы `$$`:

`ps –p $$`

![](https://ravesli.com/wp-content/uploads/2021/03/14.png)

Не трудно заметить, что в настоящее время используется оболочка bash. Для просмотра всех доступных оболочек в вашей системе, необходимо обратиться к содержимому файла _/__etc/__shells_:

`cat /etc/shells`

![](https://ravesli.com/wp-content/uploads/2021/03/15.png)

  

## Типы командных оболочек

В *nix-системах существует два основных типа оболочек: оболочки на основе Bourne shell и оболочки на основе C shell.

**Типичными представителями оболочек типа Bourne shell являются:**

   sh (Bourne shell)

   bash (Bourne Again shell)

   ksh (Korn shell)

   zsh (Z Shell)

**К оболочкам типа C Shell относятся:**

   csh (C shell)

   tcsh (TENEX/TOPS C shell)

Ниже представлены некоторые из самых распространенных шеллов, используемых в *nix-системах:

![](https://ravesli.com/wp-content/uploads/2021/03/3.png)

**_Примечание:_** Термин _«*nix-системы»_ обозначает [**Unix**](https://ravesli.com/linux-protiv-unix-v-chem-raznitsa/#toc-0)-подобные операционные системы.

---

### sh (Bourne shell)

**sh** (сокр. от _«__Bourne_ _**sh**ell»_) — это самая старая (среди рассматриваемых) оболочка, написанная Стивеном Борном из AT&T Bell Labs для ОС UNIX v7. Оболочка доступна практически в любом *nix-дистрибутиве. Многие другие шеллы уходят своими корнями именно к sh. Благодаря своей скорости работы и компактности, данная оболочка является предпочтительным средством для написания shell-скриптов. К её недостаткам можно отнести отсутствие функций для использования оболочки в интерактивном режиме, а также отсутствие встроенной обработки арифметических и логических выражений.

![](https://ravesli.com/wp-content/uploads/2021/03/6.png)

**_Примечание:_** Стоит отметить, что из-за общего морального устаревания оболочки, в современных системах ссылка на шелл sh (_/bin/sh_), обычно, является псевдонимом для запуска текущей, более новой оболочки.

Характерные черты sh:

   Полные пути к интерпретатору: _/bin/sh_ и _/sbin/sh_.

   Приглашение для обычного пользователя: `$`.

   Приглашение для суперпользователя (root): `#`.

---

### bash (Bourne-Again shell)

**bash** (сокр. от _«_**_B_**_ourne–_**_A_**_gain_ **_sh_**_ell__»)_ — это усовершенствованный и дополненный вариант шелла sh, является одной из самых популярных современных командных оболочек *nix-систем.

   Совместим с sh.

   Объединяет в себе полезные фишки оболочек ksh и csh.

   Поддерживает навигацию при помощи стрелок, благодаря чему можно просматривать историю команд и выполнять редактирование прямо в командной строке.

![](https://ravesli.com/wp-content/uploads/2021/03/7.png)

Характерные черты bash:

   Полный путь к интерпретатору: _/bin/bash_.

   Приглашение для обычного пользователя: `имя_пользователя@имя_хоста:~$` (где `~` — это домашний каталог текущего пользователя, например, `mrsmith@mypc:~$`).

   Приглашение для суперпользователя (root): `root@имя_хоста:~#`.

---

### ksh (Korn shell)

**ksh** (сокр. от _«_**_K_**_orn_ **_sh_**_ell__»_) — это командная оболочка, разработанная Дэвидом Корном из AT&T Bell Labs в 1980-x годах.

   Является расширением sh.

   Имеет обратную совместимость с sh.

   Имеет интерактивный функционал, сравнимый с csh.

   Включает в себя удобные для программирования функции, такие как: встроенную поддержку арифметических выражений/функций, Си-подобный синтаксис скриптов и средства для работы со строками.

   Работает быстрее, чем csh.

   Может запускать скрипты, написанные для sh.

![](https://ravesli.com/wp-content/uploads/2021/03/7a.png)

Характерные черты ksh:

   Полный путь к интерпретатору: _/bin/ksh_.

   Приглашение для обычного пользователя: `$`.

   Приглашение для суперпользователя (root): `#`.

---

### csh (C shell)

**csh** (сокр. от _«_**_C_** **_sh_**_ell__»_) — это командная оболочка, созданная Биллом Джоем (автором редактора _vi)_ с целью усовершенствования стандартного шелла Unix (sh).

   Имеет встроенные функции для интерактивного использования, например, псевдонимы (aliases) и историю команд.

   Включает в себя удобные для программирования функции, такие как: встроенную поддержку арифметических выражений и Cи-подобный синтаксис скриптов.

![](https://ravesli.com/wp-content/uploads/2021/03/8.png)

Характерные черты csh:

   Полный путь к интерпретатору: _/bin/csh_.

   Приглашение для обычного пользователя: `%`.

   Приглашение для суперпользователя (root): `#`.

---

### tcsh (TENEX C Shell)

**tcsh** (сокр. от _«_**_T_**_ENEX_ **_C_** **_sh_**_ell__»_) — это командная оболочка, созданная Кэном Гриром, которая позиционируется как улучшенная версия шелла csh.

   Имеет полную совместимость csh.

   Именно в данном шелле впервые появилась функция автодополнения команд и путей.

   Удобна для интерактивной работы.

   Поддерживает редактор командной строки в стиле _vi_ или _emacs._

   Является стандартным шеллом во FreeBSD.

![](https://ravesli.com/wp-content/uploads/2021/03/9.png)

Характерные черты tcsh:

   Полный путь к интерпретатору: _/bin/tcsh_.

   Приглашение для обычного пользователя: `имя_хоста:~>`.

   Приглашение для суперпользователя (root): `#`.

---

### zsh (Z Shell)

**zsh** (сокр. от _«_**_Z_** **_sh_**_ell__»_) — это командная оболочка, созданная Паулем Фалстадом во время его учебы в Принстонском университете, позиционируется как свободная современная sh-совместимая командная оболочка.

   Среди стандартных шеллов больше всего похожа на ksh, но включает в себя множество улучшений.

   Встроенная поддержка программируемого автодополнения команд, имен файлов и пр.

   Поддержка проверки орфографии и опечаток.

   Раздельная история команд для одновременной работы с несколькими запущенными шеллами.

![](https://ravesli.com/wp-content/uploads/2021/03/10.png)

Характерные черты zsh:

   Полный путь к интерпретатору: _/bin/zsh_.

   Приглашение для обычного пользователя: `имя_хоста%`.

   Приглашение для суперпользователя (root): `root@имя_хоста:~#`.

---

## Резюмируем

Краткая сводная таблица для 6 вышерассмотренных командных оболочек:

|   |   |   |   |
|---|---|---|---|
|**Командная оболочка**|**Путь**|**Приглашение (обычный пользователь)**|**Приглашение (root)**|
|**sh (Bourne Shell)**|/bin/sh и /sbin/sh|$|#|
|**bash (Bourne-Again Shell)**|/bin/bash|имя_пользователя@имя_хоста:~$|имя_пользователя@имя_хоста:~#|
|**ksh (Korn Shell)**|/bin/ksh|$|#|
|**csh (C Shell)**|/bin/csh|%|#|
|**tcsh (TENEX C Shell)**|/bin/tcsh|имя_хоста:~>|#|
|**zsh (Z Shell)**|/bin/zsh|%|#|

**_Примечание:_** Помимо представленных выше оболочек, есть еще и такие оболочки, как:

   **mksh** — оболочка, основной упор в которой сделан на написание скриптов;

   **dash** — более легковесная в сравнении с bash оболочка, но из-за этого обладающая ограниченной функциональностью;

   **fish** — «новая» оболочка, написанная в 2005 году, отличительной чертой которой является упор на комфорт использования и упрощение командного языка;

   и другие.

### [Что такое bash в Linux? Гайд по созданию bash-скриптов](https://ravesli.com/bash-v-linux/)
**bash** (сокр. от _«_**_B_**_ourne-**A**gain **sh**ell»_) — это командная оболочка (или _«интерпретатор командной строки»_), используемая по умолчанию в операционных системах на базе Unix и [**Linux**](https://ravesli.com/chto-takoe-linux-ego-struktura-i-preimushhestva/ "Что такое Linux?"), созданная в 1989 году Брайаном Фоксом с целью усовершенствования [**командной оболочки sh**](https://ravesli.com/shell-v-linux/#toc-4).

bash позволяет автоматизировать различные задачи, устанавливать программное обеспечение, настраивать конфигурации для своего рабочего окружения и многое другое. В этой статье мы рассмотрим использование нескольких основных команд в bash, а также рассмотрим гайд по созданию bash-скриптов.

Оглавление:

1. [Что такое терминал?](https://ravesli.com/bash-v-linux/#toc-0)
2. [Команды в bash](https://ravesli.com/bash-v-linux/#toc-1)
3. [Редактор nano](https://ravesli.com/bash-v-linux/#toc-2)
4. [Гайд по созданию bash-скриптов](https://ravesli.com/bash-v-linux/#toc-3)
    - [Создание bash-скрипта](https://ravesli.com/bash-v-linux/#toc-4)
    - [Выполнение bash-скрипта](https://ravesli.com/bash-v-linux/#toc-5)
    - [Команда echo](https://ravesli.com/bash-v-linux/#toc-6)
    - [Комментарии](https://ravesli.com/bash-v-linux/#toc-7)
    - [Объявление и использование переменных](https://ravesli.com/bash-v-linux/#toc-8)
    - [Условный оператор if](https://ravesli.com/bash-v-linux/#toc-9)
    - [Оператор else if](https://ravesli.com/bash-v-linux/#toc-10)
    - [Цикл while](https://ravesli.com/bash-v-linux/#toc-11)
    - [Цикл for](https://ravesli.com/bash-v-linux/#toc-12)
5. [Заключение](https://ravesli.com/bash-v-linux/#toc-13)

## Что такое терминал?

**Терминал** — это программа, которая используется для взаимодействия с [**шеллом**](https://ravesli.com/shell-v-linux/ "Что такое shell? Типы shell в Linux и Unix"). Это просто интерфейс к нему и другим программам командной строки, которые работают внутри нее. Вот как выглядит типичный терминал (_Konsole_) в Debian 11 ([**окружение рабочего стола**](https://ravesli.com/kakoe-okruzhenie-rabochego-stola-vybrat-v-linux-sravnenie-kde-vs-gnome-vs-xfce-vs-lxde/ "Какое окружение рабочего стола выбрать в Linux? Сравнение KDE vs GNOME vs Xfce vs LXDE") — KDE Plasma):

![](https://ravesli.com/wp-content/uploads/2021/03/4-1.png)

_Типичный терминал в_ _Linux_

Всякий раз, когда мы открываем окно терминала, мы видим **приглашение шелла** — `имя_пользователя@имя_машины:~$`. Символ `$` означает, что мы работаем под учетной записью обычного пользователя, а символ `~` (тильда) означает, что в данный момент мы находимся в домашнем каталоге _/home/<имя_пользователя>._  

## Команды в bash

  

**Команда в bash** — это наименьшая единица кода, которую bash может выполнить. С помощью команд мы сообщаем шеллу, что нам нужно, чтобы он сделал. bash обычно принимает от пользователя одну команду и возвращается к нему после того, как команда будет выполнена. Чтобы немного освоиться в bash, давайте попробуем выполнить несколько простых команд.

**Команда** **echo** — возвращает всё, что вы вводите в командной строке:

![](https://ravesli.com/wp-content/uploads/2021/03/7-1.png)

_Пример использования команды echo_

**Команда** **date** — отображает текущее время и дату:

![](https://ravesli.com/wp-content/uploads/2021/03/8-1.png)

_Пример использования команды date_

**Команда** **pwd** (сокр. от _«_**_p_**_rint_ **_w_**_orking_ **_d_**_irectory»_) — указывает на текущий рабочий каталог, в котором команды шелла будут искать файлы.

Файловая иерархия в Linux имеет древовидную структуру, поэтому, чтобы добраться до указанного каталога или файла, нам нужно пройти определенный путь, каждый узел которого отделен от других узлов символом `/`.

![](https://ravesli.com/wp-content/uploads/2021/03/11.png)

_Пример использования команды pwd_

**Команда** **ls** (сокр. от _«_**_l_**_i**s**t»_) — отображает содержимое каталога. Обычно, команда `ls` начинает с просмотра нашего домашнего каталога. Это означает, что если мы просто напечатаем `ls`, то данная команда выведет содержимое текущего каталога, которым в нашем примере является домашний каталог _/home/diego_:

![](https://ravesli.com/wp-content/uploads/2021/03/12.png)

_Пример использования команды ls_

**Команда cd** (сокр. от _«_**_c_**_hange_ **_d_**_irectory»_) — изменяет текущую директорию на заданную пользователем. Рассмотрим некоторые примеры использования данной команды:

   `cd <директория>` — меняет текущую директорию на заданную. Давайте попробуем с помощью команды `ls` перейти к корневому каталогу `/` и ознакомимся с его содержимым. Обратите внимание, что мы также можем использовать точку с запятой `;` для записи двух команд в одной строке.

![](https://ravesli.com/wp-content/uploads/2021/03/15-1.png)

_Пример объединения двух команд в одной строке_

   `cd ..` — вернуться в родительский каталог.

   `cd` — вернуться в домашний каталог.

**Команда** **mkdir** (сокр. от _«_**_m_**_a**k**e_ **_dir_**_ectory»_) _—_ создает новый каталог.

**Команда mv** (сокр. от _«_**_m_**_o**v**e»_) — перемещает один или несколько файлов/каталогов из одного места в другое (заданное пользователем). Для этого нужно указать, что мы хотим переместить (т.е. источник), и куда мы хотим переместить (т.е. пункт назначения).

В качестве примера я создам новый каталог _Ravesli_ в своей домашней директории и перемещу в него все _.__txt_-файлы (ну как «все», у меня там только один файл — _Адреса.__txt_) из _/__home/__diego/Документы/_ с помощью двух вышеприведенных команд:

![](https://ravesli.com/wp-content/uploads/2021/03/16.png)

_Перемещение файлов с помощью команды mv_

**Команда touch** — создает новые пустые файлы (а также изменяет временные метки в существующих файлах и каталогах). Вот как мы можем создать пустой файл под названием _foo.txt_ в папке _Ravesli_ из домашнего каталога:

![](https://ravesli.com/wp-content/uploads/2021/03/17.png)

_Создание файла с помощью команды_ _touch_

**Команда** **rm** (сокр. от _«_**_r_**_e**m**ove»_) — удаляет файлы/каталоги. По умолчанию, команда `rm` НЕ удаляет каталоги, но если используется как `rm -r *` внутри заданного каталога, то каждый подкаталог и файл внутри заданного каталога — удаляются.

Давайте удалим ранее созданный файл _foo.__txt_:

![](https://ravesli.com/wp-content/uploads/2021/03/18.png)

_Удаление файла с помощью команды_ _rm_

**Команда** **rmdir** (сокр. от _«_**_r_**_e**m**ove_ **_dir_**_ectory»_) — удаляет каталоги.

Давайте удалим созданный ранее каталог _/__home/__diego/__Ravesli_:

![](https://ravesli.com/wp-content/uploads/2021/03/19.png)

_Удаление каталогов с помощью команды_ _rmdir_

**Команда cat** (сокр. от _«con**cat**enate»_) — считывает файл и выводит его содержимое. Она может работать с несколькими файлами, объединяя их вывод в единый поток (отсюда и происходит её название). У меня в домашнем каталоге есть папка _untitled_ с файлами [**С++/Qt**](https://ravesli.com/uroki-po-qt5/)-проекта, и ниже я использую команду `cat` для просмотра содержимого файла _main.__cpp_ из _untitled_:

![](https://ravesli.com/wp-content/uploads/2021/03/20.png)

_Пример использования команды_ _cat_

Чтобы просмотреть несколько файлов, укажите друг за другом (через пробел) имена требуемых файлов после команды `cat`, например:

![](https://ravesli.com/wp-content/uploads/2021/03/21.png)

_Просмотр нескольких файлов с помощью команды_ _cat_

**Команда man** (сокр. от _«**man**ual»_) — отображает справочные страницы, которые являются руководством пользователя, встроенным по умолчанию во многие [**дистрибутивы Linux**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/ "Обзор дистрибутивов Linux. Какой выбрать?") и большинство систем Unix. Например, команда `man bash` отобразит руководство пользователя, а команда `man ls` отобразит справку по команде `ls`.

![](https://ravesli.com/wp-content/uploads/2021/03/22.png)

_Отображение справочной информации с помощью команды_ _man_

## Редактор nano

**nano** — это маленький, простой, консольный текстовый редактор *nix-подобных операционных систем, впервые увидевший свет в далеком 1999 году. Для запуска редактора достаточно ввести в терминале всего одну команду — `nano`. Если же нужно отредактировать какой-то конкретный файл, то применяется команда `nanо /<путь_к_файлу/<имя_файла>`. Отличительной чертой данного редактора является то, что он управляется сочетаниями клавиш. Например, для сохранения текущего документа применяется сочетание _Ctrl+O_, для вызова меню поиска — _Ctrl+W_, для выхода из редактора — _Ctrl+X_, а для получения всего списка доступных сочетаний клавиш — _Ctrl+G_.

![](https://ravesli.com/wp-content/uploads/2021/03/28_1.png)  

## Гайд по созданию bash-скриптов

  

Наш шелл, это не только промежуточное звено между пользователем и системой, но еще и мощный язык программирования. Программы, написанные на языке шелла, называются _shell-скриптами_ (или _shell-сценариями_) и имеют соответствующее расширение файлов — _.sh._ Сам язык содержит полный набор утилит и команд, доступных в *nix-системах, а также циклы, условные операторы, объявление переменных и пр. Такие скрипты будут очень полезными там, где не требуется использование полноценных языков программирования, например, в задачах администрирования операционной системы.  

### Создание bash-скрипта

Чтобы создать новый файл bash-скрипта, откройте в любом редакторе текстовый файл и сохраните его с расширением _.sh_. Все дальнейшие эксперименты я будут проводить в Debian Linux, с применением текстового редактора _nano_.

Давайте создадим новый файл _ravesli.sh_:

`diego@debian:~$ touch ravesli.sh   diego@debian:~$ ls -l   -rw-r--r-- 1 diego diego    0 мар  9 14:59  ravesli.sh   diego@debian:~$`

Чтобы выполнить файл bash-скрипта, нужно изменить [**права доступа**](https://ravesli.com/tipy-polzovatelej-i-prava-dostupa-k-fajlam-katalogam-v-linux/#toc-1) к файлу и сделать его исполняемым. Разрешение, как вы наверняка помните из предыдущих уроков, изменяется командой `chmod +x <имя_файла>`:

`diego@debian:~$ chmod +x ravesli.sh   diego@debian:~$ ls -l   итого 40   drwxr-xr-x 2 diego diego 4096 фев 27 00:23  build-untitled-Desktop-Debug   -rw**x**r-**x**r-**x** 1 diego diego    0 мар  9 14:59  ravesli.sh`  

### Выполнение bash-скрипта

Файл bash-скрипта может быть запущен двумя способами:

   _Способ №1:_ `bash <имя_файла>`. Чтобы выполнить скрипт, просто напишите в терминале команду `bash`, а затем (через пробел) имя файла и нажмите Enter.

   _Способ №2:_ `./<имя_файла>`. Чтобы выполнить скрипт введите команду `./<имя_файла>` и нажмите Enter.

### Команда echo

**Команда echo** — это самая фундаментальная и базовая команда в bash-скриптах. Её основное предназначение заключается в выводе любой информации на экран. Давайте откроем c помощью _nano_ (или любого другого текстового редактора) файл _ravesli.sh_ и попробуем применить команду `echo` для вывода некоторого текста в терминале.

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4|#!/bin/bash<br><br>echo "Привет, Ravesli !"<br><br>echo "Эта команда была выполнена с помощью bash-скрипта"|

Далее, нажимаем _Ctrl+O_ для сохранения изменений и _Ctrl+X_ для выхода из _nano_.

_**Примечание:**_ Каждый bash-скрипт всегда должен начинаться со строки:

|   |   |
|---|---|
|1|#!/bin/bash|

В данной строке после `#!` указывается путь к командной оболочке bash. Если у вас bash находится в другом месте, то с помощью команды `whereis bash` вы можете узнать, где именно, и указать свой путь.

Запустим наш файл и увидим:

`diego@debian:~$ ./ravesli.sh   Привет, Ravesli !   Эта команда была выполнена с помощью bash-скрипта   diego@debian:~$`

![](https://ravesli.com/wp-content/uploads/2021/03/29.gif)  

### Комментарии

**Комментарии** — это важная часть компьютерных программ. Они являются неисполняемыми строками, улучшающими читабельность кода и помогающими понять его назначение. В файле bash-скрипта мы можем добавлять однострочные и многострочные комментарии:

   **однострочные комментарии** начинаются с символа `#`;

   **многострочные комментарии** начинаются с одинарной кавычки `'`, а символ двоеточия `:` используется для добавления строк в комментарий.

Давайте рассмотрим простой пример применения комментариев в bash-скриптах:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10|#!/bin/bash<br><br># Применение команды echo<br><br># Это – однострочный комментарий<br><br>echo "Всем привет! Это – пример однострочного комментария!"<br><br>: '<br><br>А вот – многострочный комментарий<br><br>Давайте еще раз применим команду echo<br><br>'<br><br>echo "Bash – крутая штука"|

Результат:

![](https://ravesli.com/wp-content/uploads/2021/03/30.png)  

### Объявление и использование переменных

Вы наверняка помните, что переменные нужны для хранения данных или некоторой информации. Они являются важным аспектом любого языка программирования. Использовать переменные в bash очень просто — они объявляются путем написания своего имени. В дальнейшем, при обращении к переменной мы должны указать символ `$` вместе с ней.

Давайте объявим и применим переменную в нашем файле bash-скрипта:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19|#!/bin/bash<br><br>#объявляем переменную<br><br>VAR="Добро пожаловать на Ravesli.com !"<br><br>#используем переменную<br><br>echo $VAR<br><br>#объявляем переменную num1<br><br>num1=10<br><br>#объявляем переменную num2<br><br>num2=20<br><br>#вычисляем сумму и сохраняем её в переменной num3<br><br>num3=$(($num1+$num2))<br><br>#выводим на экран переменную sum<br><br>echo "Сумма: $num3"|

Результат:

![](https://ravesli.com/wp-content/uploads/2021/03/32.png)  

### Условный оператор if

Условные операторы в bash используются для принятия решений. В условных операторах вычисляется конкретное условие. Если условие истинно (true), то выполняется первый блок кода. В противном случае (false) выполняется второй блок кода.

Мы можем вычислить одно или несколько условий внутри блока if с помощью операторов OR (`||`) и AND (`&&`). В bash блок if начинается с ключевого слова `if` и заканчивается ключевым словом `fi`. Если заданное условие ложно, то выполняется блок else.

Давайте посмотрим, как выполняются условные операторы в bash. Мы объявили переменную, а затем вычисляем её и принимаем решение на основе её значения. При этом, для проверки по типу «меньше, чем» применяется запись `–lt`, для «больше, чем» — запись `-gt`, а для проверки на «равно» — запись `-eq`:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10|#!/bin/bash<br><br>#объявляем переменную<br><br>VAR=7<br><br>if [ $VAR -lt 10 ];<br><br>then<br><br>echo "Число меньше 10"<br><br>else<br><br>echo "Число равно 10"<br><br>fi|

Результат:

![](https://ravesli.com/wp-content/uploads/2021/03/33.png)

Вывод показывает, что `Число меньше 10`, потому что значение переменной равно 7, что явно меньше 10. В данном примере выполняется условие.

Аналогично, мы можем использовать условие OR (`||`) и AND (`&&`) внутри блока if для вычисления нескольких условий. Давайте рассмотрим пример оператора OR:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12|#!/bin/bash<br><br>#объявляем переменную<br><br>VAR=7<br><br>#используем оператор OR в if-условии<br><br>if [[ ( $VAR -gt 5 ) \| ( $VAR -eq 7 ) ]]<br><br>then<br><br>echo "Число больше 5 или равно 7"<br><br>else<br><br>echo "Число не больше 5 и не равно 7"<br><br>fi|

Результат:

![](https://ravesli.com/wp-content/uploads/2021/03/34.png)

Теперь давайте реализуем оператор AND внутри условия if. В операторе AND оба условия должны быть истинными.

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12|#!/bin/bash<br><br>#объявление переменной<br><br>VAR=7<br><br>#используем оператор AND в if-условии<br><br>if [[ ( $VAR -gt 5 ) && ( $VAR -lt 10 ) ]]<br><br>then<br><br>echo "Были выполнены оба условия"<br><br>else<br><br>echo "Условия не были выполнены"<br><br>fi|

Результат:

![](https://ravesli.com/wp-content/uploads/2021/03/35.png)  

### Оператор else if

Оператор else if используется для вычисления нескольких условий. Чтобы определить оператор else if, применяется ключевое слово `elif`.

Давайте рассмотрим пример с пользовательским вводом (ключевое слово `read` используется для получения входных данных от пользователя):

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19|#!/bin/bash<br><br>echo "Введите число"<br><br>read num<br><br>#объявляем переменную<br><br>if [ $num -gt 10 ];<br><br>then<br><br>echo "Число больше 10"<br><br>elif [ $num -eq 10 ];<br><br>then<br><br>echo "Число равно 10."<br><br>elif [ $num -lt 10 ];<br><br>then<br><br>echo "Число меньше 10"<br><br>else<br><br>echo "Некорректное число"<br><br>fi|

Результат:

![](https://ravesli.com/wp-content/uploads/2021/03/36.png)  

### Цикл while

Цикл while используется для многократного выполнения кода. Он вычисляет условие и продолжает выполнение до тех пор, пока условие не станет ложным. Синтаксис цикла while в bash выглядит следующим образом:

`while [условие]   do   выражения_и_команды   done`

Если `[условие]` истинно, то выполняется блок `do`.

Ниже представлен пример цикла while. Цикл продолжает выполнение до тех пор, пока значение переменной не станет меньше 10. Внутри блока do мы увеличиваем значение переменной на 1 в каждой итерации. Цикл завершается, когда условие становится ложным.

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11|#!/bin/bash<br><br>#объявление переменной<br><br>VAR=1<br><br>while [ $VAR -le 10 ]<br><br>do<br><br>       echo "Значение переменной =  $VAR"<br><br>       #увеличиваем значение переменной на 1<br><br>       (( VAR++ ))<br><br>done|

Результат:  
![](https://ravesli.com/wp-content/uploads/2021/03/37.png)  

### Цикл for

Цикл for также применяется для многократного выполнения одного и того же блока кода. Синтаксис цикла for в bash выглядит следующим образом:

`for ((объявление_переменных; условие; инкремент/декремент_счетчика))   do   выражения_и_команды   done`

Рассмотрим пример цикла for, в котором будем увеличивать значение переменной и выводить его в каждой итерации:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10|#!/bin/bash<br><br>#объявляем цикл for<br><br>for ((i=0; i<10; i++))<br><br>do<br><br>  #выводим на экран значение переменной<br><br>  echo -n "$i "<br><br>done<br><br>echo "\n"|

Результат:  
![](https://ravesli.com/wp-content/uploads/2021/03/38.png)  

## Заключение

Инструменты командной строки могут стать для вас отличными помощниками в плане автоматизации рутинных задач. Поначалу всё это может вас напугать, но стоит вам немного освоиться с консолью и написанием скриптов, как вы сразу почувствуете всю силу, мощь и громадный потенциал данного инструмента.