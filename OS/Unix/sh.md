[http://forum.ru-board.com/topic.cgi?forum=65&bm=1&topic=2790&start=2800#lt](http://forum.ru-board.com/topic.cgi?forum=65&bm=1&topic=2790&start=2800#lt)

[https://ru.wikibooks.org/wiki/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2_%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_UNIX/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0_UNIX](https://ru.wikibooks.org/wiki/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2_%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_UNIX/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0_UNIX)

Крупнейшая база полезных однострочников на командной оболочке с ранжированием на основе пользовательского голосования.

[https://www.commandlinefu.com/commands/browse/sort-by-votes](https://www.commandlinefu.com/commands/browse/sort-by-votes)

Аналогично, но поменьше и формат записей более свободный, поэтому встречаются и однострочники, и развернутые скрипты, и просто советы.

[http://www.shell-fu.org/lister.php?top](http://www.shell-fu.org/lister.php?top)

Почти исчерпывающий список решений для тех случаев, когда sed незаменим. Более сложные скрипты с sed.sf.net — только для тех, кто знает толк... :)

[http://sed.sourceforge.net/sed1line.txt](http://sed.sourceforge.net/sed1line.txt)

[https://abclinux.org/shell-skripty-dlya-ubuntu-linux](https://abclinux.org/shell-skripty-dlya-ubuntu-linux)

# Введение в администрирование UNIX/Командная строка UNIX
https://ru.wikibooks.org/wiki/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2_%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_UNIX/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0_UNIX


# Shell скрипты для Ubuntu Linux

• [Юрий Герук](https://abclinux.org/index/8-590)

• 2016-12-30

• [Инструкции](https://abclinux.org/manual-linux)

• 4852

• [3](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#comments)

• 10 минут

**Содержание**

[1. Небольшая подборка полезных Shell скриптов для использования в Linux](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Небольшая-подборка-полезных-Shell-скриптов-для-использования-в-Linux)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Небольшая-подборка-полезных-Shell-скриптов-для-использования-в-Linux)[2. Начнем с простых примеров](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Начнем-с-простых-примеров)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Начнем-с-простых-примеров)[3. Сводка погоды в консоли](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Сводка-погоды-в-консоли)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Сводка-погоды-в-консоли)[4. Для рабочего стола](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Для-рабочего-стола)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Для-рабочего-стола)[5. Ищем в Google из командной строки](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Ищем-в-Google-из-командной-строки)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Ищем-в-Google-из-командной-строки)[6. Вывод](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Вывод)

[](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#Вывод)

Ошибка в тексте? Выделите ее мышкой! И нажмите: CTRL+Enter, [сообщите об этом](https://abclinux.org/shell-skripty-dlya-ubuntu-linux#erorr), автор постарается в краткие сроки обновить / исправить материал.

#### Примеры подстановки и замены в переменной:
```
name="srv.domain.ru";
newname="${name//.}";
echo $newname;
 
name1="srv.domain.ru";
newname1="${name1//./_}";
echo $newname1;
 
name2="$(date +"%Y_%m_%d_%H_%M")";
newname2="${name2//_}";
echo $newname2;

name=t.e.s.t
echo "${name//.}"
test
echo "${name//./_}"
t_e_s_t
 
name=t.e.s.t
echo $name | tr -d \.
test
echo $name | sed 's/\.//g'
test
echo $name | sed 's/\.//g'
test
echo $name | sed 's/\./_/g'
t_e_s_t
```


### Небольшая подборка полезных Shell скриптов для использования в Linux

Консоль Linux - это тот инструмент который позволяет выполнять такие манипуляции, которые не позволяет творить командная строка в Windows, консоль Linux, это визитная карточка UNIX. Сегодня материал не о том как писать скрипты, нет, я вас не буду учить как, что и для чего. Мы рассмотрим небольшую подборку полезных скриптов, которые вы сможешь применять ежедневно для решения задач разного рода, например посмотреть погоду на несколько дней вперед, скрипты для веб-сервера в одну строку, написание бота для твиттера и скриптом для автоматического запуска любого торрент-клиента.

[![file://e:/Temp/app/.SBYMW1/1.png](file://e:/Temp/app/.SBYMW1/1.png)](https://abclinux.org/picte/other/bash-shell.png)

Этот материал написан, не чтобы вы занимались шаманизмом, ни в коем случае я вас не призываю сидеть в консоли и печатать сотни символов, чтобы выполнить некоторые действия, которые вы можете выполнить в графическом интерфейсе лишь наведя мышку на необходимый вам элемент. Но есть одно но, не всегда графический интерфейс является лучшим решением, часто для решения многих задач консоль и скрипты справляются с поставленной задачей намного лучше чем приложения с графическим интерфейсом, в связи с чем о скриптах забывать нельзя так как много рутинной работы они решают лучше графических инструментов. Стоит так же добавить, что любая DE позвoляет вам создать для ваших скриптов иконку, нажав на которую, вы сможете их легко запустить не открывая консоль.

## Начнем с простых примеров

Команда ниже покажет вам ваш внешний IP - это идеальный вариант, если в Сеть вы входите используя роутер. Эта команда обращается к серверу ifconfig.co, который возвращает IP одной строкой без лишней писанины которая вам не нужна.

curl ifconfig.co

Да, это не скрипт, это небольшая команда, но если вы хотите превратить эту команду в скрипт, вам достаточно поместить ее в текстовый файл, в итоге у нас получится небольшой bash скрипт:

#!/bin/bash

curl ifconfig.co

Сохраняeм скрипт в каталог ~/bin и даем права на исполнение:

chmod +x ~/bin/yourip.sh

Почти готово, вы можно исполнить скрипт из командной строки используя команду yourip.sh.

C айпи закончили, посмотрим погоду с консоли.

## Сводка погоды в консоли

#!/bin/sh

curl -4 wttr.in/Kiev

Этот скрипт позволяет получить сводку погоды на четыре дня, в данном случае погода для города Киев.

[![file://e:/Temp/app/.SBYMW1/2.png](file://e:/Temp/app/.SBYMW1/2.png)](https://abclinux.org/post1/other/pogoda-kiev.jpeg)

#!/bin/sh

dig +short txt $1.wp.dg.cx

Выше вы видите пример, как можно получить краткое описание чего-нибудь в Википедии, в нашем случае мы используем DNS-запрос вместо обращения к веб-серверу. Веб-сервер через консоль также очень легко создать:

#!/bin/sh

while ( nc -l 80 < file.html > : ) ; do : ; done

Скрипт выше основан на утилите netcat (nc), часто ее называют швейцарским армейским ножом, так как позволяет вытворять много трюков для сетевых опeраций. Скрипт простой он запускает цикл, который выполняет команду nc, та уже слушает 80-й порт и в ответ на запрос отдает _file.html_, отправляя переданный запрос в никуда (символ означает noop, то есть пустую операцию).

Используя простые скрипты и команд, вы можете слушать интернет-радио:

#!/bin/sh

mpv --volume=50 -playlist ~/16bit.fm_128.m3u

Конечно, до этого вам нужно скачать плей-лист радио в формате M3U с сайта радиостанции. Если зaпустить MPlayer используя аргумент _—input-ipc-server=/tmp/mpvsocket_, им можно будет управлять, записывая команды в файл. Например, настроить громкость:

echo 'volume +10' | socat - /tmp/mpvsocket

Создаем два скрипта: первый для запуска, а другой для остановки радио (в котором мы пропишем строку killall mpv), далее повесь на рабочий стол совместно настроив горячие клавиши DE для управления воспроизведением. И готово, вы имеете плеер с помощью которого вы можете заускать интернет-радио.

Увлеклись сетевыми операциями, перейдем к локальным.

#!/bin/sh

tar -czf "../${PWD##*/}.tar.gz" .

Это скрипт создает архив tar.gz для текущего кaталога. Особое внимание нужно уделить конструкции ${PWD##*/}, которая бeрет весь путь до текущего каталога (переменная $PWD) далее удаляет первую чаcть до последнего слеша, в итоге остается лишь имя каталoга и к нему добавляется расширение tar.gz. Если вы хотите узнать больше информации по подобных конструкциях, вы можете прочитать выполнив в консоли команду man bash.

#!/bin/sh

while true; do

inotifywait -r -e MODIFY КАТАЛОГ && ТВОЯ_КОМАНДА

done

Скрипт выше запускает команду в ответ на изменение файлов в каталоге. Вы ее можете применять для разных целей, как пример для автоматического включения плеера при сохранении MP3. Или же как пример выводить увeдомление на рабочий стол, используя команду notify-send:

notify-send "Файл изменен"

## Для рабочего стола

Ниже вы увидите пример скрипта, который загружает случайные обои, которые опубликованы на reddit-канале wallpaper:

#!/bin/bash

wget -O - http://www.reddit.com/r/wallpaper |\

grep -Eo 'http://i.imgur.com[^&]+jpg' |\

shuf -n 1 |\

xargs wget -O background.jpg

feh --bg-fill background.jpg

Работает все довольно просто. Используя утилиту wget скрипт загружает страницу www.reddit.com/r/wallpaper, далее передает ее grep, который уже ищет ссылки на imgur, и выбирает случайную с помощью shuf, загружает ее с помощью wget и устанавливает в качестве обоев для вашего рабочего стола, используя команду feh (это миниатюрный просмотрщик изображений, который нужно предварительно устанoвить). Вы этот скрипт можете добавить в обычный текстовый файл как я описывал выше, сохранить в формате sh, сделать исполняемым, добавить к нему иконку и запускать с рабочего стола по клику и у вас будут меняться обои.

#!/bin/sh

state=`synclient | grep TouchpadOff | cut -d '=' -f 2`

if [ $state = "1" ]; then

synclient TouchpadOff=0

else

synclient TouchpadOff=1

fi

Скрипт выше используется для включения и выключения тачпада вашего ноутбука: включает, если отключен, и наоборот. Для корректной работы в нем используется утилита synclient, которая и позволяет управлять тачпадами которые в большинстве производит Synaptics, это 90% возможно даже и более. После запуска утилита выводит много информации, так же строку TouchpadOff = 1, если он активирован, и TouchpadOff = 2, если отключен. Скрипт прочитав эти значение и в зависимости от состояния тачпада включит или отключит его.

!#/bin/bash

mpv tv:// -frames 3 -vo jpeg

mv 00000003.jpg photo.jpg

rm -f 0000*.jpg

Используя скрипт выше, вы можете создать снимок используя веб-камеру. В скрипте используется видеоплеер mpv который записывает первые три кадра, снятые камерой, в файлы JPEG формата с именами 0000000.jpg, 00000002.jpg, 00000003.jpg итд, после переименовывается третий снимок в файл photo.jpg, а остальные удаляются. Для чего используются три снимка? Они необходимы лишь для того, чтобы ваша камера успела провести инициализацию, если использовать первые два снимка, то обычно вы получите черный снимок. Бывают так же казусы с позиционированием, фото может быть перевернутым; чтобы этого избежать mpv нужно запускать с флагом -vf flip:

mpv tv:// -frames 3 -vf flip -vo jpeg

Эту же команду, вы можете использовать для создания камеры слежения, которая будет делает снимки лишь в те моменты, когда пользователь прикоснется к мыши:

#!/bin/bash

while true; do

sudo cat /dev/input/mouse0 | read -n1

mpv tv:// -frames 3 -vo jpeg

mv 00000003.jpg `date +%F-%H-%M`.jpg

rm -f 0000*.jpg

sleep 10

done

Скрипт выше использует бесконечный цикл, получая данные с устройства /dev/input/mouse0. Если данные есть, значит, мышь была сдвинута или была нажата одна из ее кнопок. После используется mpv, для создания трех снимков, третьему снимку присваивается имя текущей даты и удаляются первые два.

Если вы хотите записать полноценное видео с веб-камеры, как пример можно использовать подобный скрипт:

#!/bin/bash

mencoder tv:// -tv driver=v4l2:width=800:height=600:device=/dev/video0:fps=30:outfmt=yuy2:forceaudio:alsa:adevice=hw.2,0 -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=1800 -ffourcc xvid -oac mp3lame -lameopts cbr=128 -o video.avi

В результате вы получите файл с названием video.avi в формaте MPEG4, битрейт 1800 и аудиофайл в формате MP3 с битрейтом 128.

#!/bin/bash

ffmpeg -f x11grab -r 25 -s 1366x768 -i :0.0 screencast.mpg

Используя скрипт выше, вы можете записать полноценный скринкаст. 1366×768 - это разрешение рабочего стола, можете настроить под себя. Для создания скриншота отдельного окна, вы можете использовать команду import:

import screenshot.png

Если запустить команду выше, значок курсора вашей мыши изменится на крестик, используя который, вы сможете выделить область экрана как это вы делаете при создании скриншотов используя сторонние приложения или расширения. Если повесить эту команду на одну из горячих клавиш, вы получите практически идеальную систему для создания скриншотов, и эта комбинация не будет кушать вашу оперативную память, что значительно придает ей огромный плюс.

Вы также можете настроить внешний монитор используя консоль:

#!/bin/sh

if [ -z "$1" ]; then

exit

fi

if [ $1 == "off" ]; then

xrandr --output VGA-0 --off

xrandr -s 0

else if [ $1 == "on"]; then

xrandr --output LVDS --auto --primary --output VGA-0 --auto --left-of LVDS

xrandr --newmode "1920x1080" 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync

xrandr --addmode VGA-0 1920x1080

xrandr --output VGA-0 --mode 1920x1080

fi

xrandr --dpi 96

Этот скрипт основывается на том, что основной монитор имеет имя LVDS, а внешний - VGA-0. Это стандартная ситуация для всех ноутбуков; если вы не уверены, можно проверить выполнив команду xrandr: при передаче скрипту аргумента _off_ он отключает внешний монитор, аргумент _on_, в свою очередь, включает его, располагая по левую сторону от основного (аргумент _—left-of LVDS_ в первoй команде). После скрипт создает новую конфигурацию для монитоpа с разрешением 1920 x 1080 и активирует его. И под конец, скрипт устанавливает дефолтное знaчение DPI - так как при подключении монитора с другим разpешением оно часто слетает.

В большинстве случаев команды _xrandr —newmode …_ и _xrandr —addmode …_ не нужны, так как Xorg получит конфигурацию монитора и разрешение с помощью EDID. Иногда, однако, этого не происходит, и строку конфигурации, указываемую после аргумента _—newmode_, приходится генерировать самостоятельно с помощью инструмента cvt:

cvt 1920 1080

Используя инструмент cvt, можно сгенериpовать нестандартны разрешения, которые не поддерживаются монитором по умолчанию.

## Ищем в Google из командной строки

Вернемся снова к сетевым сервисам. Как получить первый 10 результатов поиска в Google? Смотрим скрипт ниже:

#!/bin/bash

Q="$@"

URL='https://www.google.de/search?tbs=li:1&q='

AGENT="Mozilla/4.0"

stream=$(curl -A "$AGENT" -skLm 10 "${GOOG_URL}${Q//\ /+}" | grep -oP '\/url\?q=.+?&amp' | sed 's|/url?q=||; s|&amp||')

echo -e "${stream//\%/\x}"

Этот скрипт отправляет запрос к Google с помощью curl, заменяет пробелы в поисковой строке на плюсы. После в ответном HTML выскакивают ссылки

Пример с сервисом YouTube:

#!/bin/bash

mpv -fs -quiet `youtube-dl -g "$1"` Скрипт с примера выше проигрывает видео с указанным в аргументе ID с помощью плеера mpv. Заранее нужно установить youtube-dl.

Несколько примеров работы с Twitter. Ниже вы увидите скрипт полноценного бота, который на входе принимает команду, выполняет ее с помощью командного интерпретатора и отправляет результат указанному юзеру.

#!/bin/bash

USER="Ваш Ник"

while true; do

CMD=`echo "/dma +1" | ttytter -script | sed 's/\[.*\]\ //'

if [ $CMD != $OLD_CMD ]; then

REPL=`$CMD`

echo "/dm $USER ${REPL:0:140}" | ttytter -script

CMD = $OLD_COMD

fi

sleep 60

done В скрипте используется консольный клиент ttytter, читая с цикла последнее значение direct message, после происходит проверка, не была ли эта команда выполнена, если нет, выполняет ее и отправляет указанному юзеру с переменной USER обрезая до 140 символов.

Чтобы все работало, вам нужно установить утилиту ttytter, запустить ее, после скопировать сгенерированную ссылку с консоли и вставить в адресную строку браузера, пройти подтверждение, согласиться, после получите ключ аутентификации, скопируйте и вставьте его в консоли в ttytter. Конечно, перед всем этим желательно добавить отдельного юзера и залогиниться под его учеткой.

Использовать твиттер можно не лишь в целях создания бота, но и для мониторинга машины. Скрипт ниже отправляет в ленту сообщение с информацией о состоянии машины (имя хоста, uptime, нагрузка, свободная память и нагрузка на CPU):

#!/bin/bash

HOST=`hostname -s`

UP=`uptime | cut -d" " -f4,5 | cut -d"," -f1`

LOAD=`uptime | cut -d":" -f5,6`

MEM=`ps aux | awk '{ sum += $4 }; END { print sum }'`

CPU=`ps aux | awk '{ sum += $3 }; END { print sum }'`

tweet="Host: ${HOST}, uptime: ${UP}, cpu: ${CPU}%, memory: ${MEM}%, loadavg ${LOAD}"

if [ $(echo "${tweet}" | wc -c) -gt 140 ]; then

echo "FATAL: The tweet is longer than 140 characters!"

exit 1

fi

echo $tweet | ttytter -script

Напоследок смотрим скрипт ниже, этот скрипт используется для запуска и остановки торрент-клиента пока ваш ПК простаивает:

#!/bin/bash

IDLE=600000

STOPCMD="transmission-remote -S"

STARTCMD="transmission-remote -s"

STOPPED="yes"

while true; do

if [ `xprintidle` -gt $IDLE ]; then

if [ $STOPPED = "yes" ]; then

$STARTCMD

STOPPED="no"

fi

else

if [ $STOPPED = "no" ]; then

$STOPCMD

STOPPED="yes"

fi

fi

sleep 60

done Каждую минуту скрипт уходит в бесконечный цикл и проверяет, сколько времени в миллисекундах прошло с момента, когда юзер выполнял последние действия (для этих целей используется xprintidle). Если прошло 600 000 мс (десять минут), скрипт выполняет команду, которая укaзана в переменной STARTCMD. В ином случае выполняется команда STOPCMD, но лишь в том случае, если до нее была выполнена STARTCMD. Если объяснить простым языком, вы ничего не делаете за компьютером десять минут, после  запускается STARTCMD, в нашем случае это команда которая запускает все закачки в Transmission, если нет - все закачки приостанавливаются. Не любите клиент Transmission? Используем команды для Deluge, смотрим ниже:

STOPCMD="deluge-console pause \*"

STARTCMD="deluge-console resume \*"

## Вывод

Описанное выше может показаться вам сложным или же лишним так как вместо писанины в консоли вы можете найти много утилит с графическим интерфейсом которые выполнят необходимые задачи в один клик без использования консоли. Да, соглашусь с вами, но не все доступно с графического интерфейса, часто именно консоль спасает от рутинной работы если уметь ей пользоваться. На этом пожалуй и окончим материал, если вы имеете чем поделиться(скриптами), оставляйте комментарии к материалу.

Источник: [xakep.ru](https://abclinux.org/go?https://xakep.ru/)

**Автор: Юрий Герук**

# Bash-скрипты, часть 10: практические примеры

[https://habr.com/ru/company/ruvds/blog/328346/](https://habr.com/ru/company/ruvds/blog/328346/)

============================================================

[http://forum.ru-board.com/topic.cgi?forum=65&bm=1&topic=2790&start=2860#lt](http://forum.ru-board.com/topic.cgi?forum=65&bm=1&topic=2790&start=2860#lt)

Доброго дня, помогите, есть такая строка

``for iface in `ifconfig | cut -c 1-8 | sort | uniq -u | grep -v lo | grep -v : `; do echo $iface; done``

если сетевой интерфейс имеет 8 символов "enp2s0s5" то все отлично работает, а если 6 символов "enp2s0" то не работает, как модифицировать код чтобы что бы работало и на 6 и на 8 символов?

Если стоит задача вывести список сетевых интерфейсов то я бы сделал это так
`netstat -i | sed 1,2d | grep -v lo | awk  '{print $1}'`

Условие 'grep -v :' неточное, поскольку символ ':' может включаться в имя интерфейса, например, если это алиас.

А какая задача-то решается? Если вывести имена всех сетевых интерфейсов, кроме lo, то может использовать что-то менее монструозное? Ну например:
`ifconfig | grep HW | awk '{print $1}'`

 Ну и таки да, может быть уже закопать стюардессу в виде net-tools, и использовать iproute2?

А ничего, что iproute2  сейчас как бы стандарт. Его можно везде встретить, а вот ifconfig aka net-tools уже не везде

Но на самом деле ты прав. Не нужно грепать по HW (это у меня видимо помутнение было). Универсальней для линуксов с net-tools будет примерно так:
 `ifconfig -s | grep -v 'Iface' | awk '{print $1}'`

или если парсить вывод утилит, то я согласен с теми кто ратовал за утилиту ip. Ибо ifconfig давно deprecated.
`ip -o link show | awk -F' |:' '{print $3}'`

### [Что такое командная оболочка (shell) в Linux?](https://ravesli.com/shell-v-linux/)
Оглавление:

1. [Что такое shell?](https://ravesli.com/shell-v-linux/#toc-0)
2. [Внутренние и внешние команды оболочки](https://ravesli.com/shell-v-linux/#toc-1)
3. [Как узнать какая оболочка у меня установлена?](https://ravesli.com/shell-v-linux/#toc-2)
4. [Типы командных оболочек](https://ravesli.com/shell-v-linux/#toc-3)
    - [sh (Bourne Shell)](https://ravesli.com/shell-v-linux/#toc-4)
    - [bash (Bourne-Again shell)](https://ravesli.com/shell-v-linux/#toc-5)
    - [ksh (Korn shell)](https://ravesli.com/shell-v-linux/#toc-6)
    - [csh (C shell)](https://ravesli.com/shell-v-linux/#toc-7)
    - [tcsh (TENEX C Shell)](https://ravesli.com/shell-v-linux/#toc-8)
    - [zsh (Z Shell)](https://ravesli.com/shell-v-linux/#toc-9)
5. [Резюмируем](https://ravesli.com/shell-v-linux/#toc-10)

## Что такое shell?

**Shell** (или **_«шелл»_**, **_«командная оболочка»_**) — это не только командный интерпретатор, который обеспечивает интерфейс взаимодействия между пользователем и ядром операционной системы, но и своеобразный язык программирования, в котором присутствуют такие конструкции, как операторы условного ветвления, циклы, переменные и многое другое.

Операционная система (ОС) запускает командную оболочку для каждого пользователя, когда тот входит в систему или открывает окно терминала. Первым что пользователь увидит в окне терминала, будет **приглашение оболочки** — оно, как правило, состоит из имени пользователя и имени хоста, отделенные друг от друга символом `@`, следом за ними идет путь текущей рабочей директории и один из двух символов: `$` или `#`.

Если пользователь не наделен особыми правами, то в качестве приглашения к вводу команд в терминале будет отображаться символ `$`. Если же был выполнен вход под учетной записью привилегированного (root) пользователя, то в терминале вы увидите символ `#`:

![](https://ravesli.com/wp-content/uploads/2021/03/1.png)

_Окно терминала обычного пользователя (виден символ $)_

![](https://ravesli.com/wp-content/uploads/2021/03/2.png)

_Окно терминала привилегированного (__root) пользователя (виден символ #)_

**_Примечание:_** Знак тильды (`~`) указывает на то, что мы находимся в домашнем каталоге текущего пользователя.

После приглашения, пользователь вводит различные команды в терминал, оболочка запускает программы для пользователя, а затем отображает в терминале результат их выполнения. Команды могут быть либо введены непосредственно самим пользователем, либо считаны из файла, называемого shell-скриптом или shell-программой.

Ниже представлен пример выполнения простой команды `date`, возвращающей текущую дату и время:

![](https://ravesli.com/wp-content/uploads/2021/03/3-1.png)  

## Внутренние и внешние команды оболочки

Вводимые пользователем команды делятся на два типа:

   **Внутренние** — это команды, изначально встроенные в оболочку.

   **Внешние** — это команды, которые не встроены в оболочку. По своей сути они являются скорее небольшими отдельными программами, расположенными где-то в файловой системе (обычно, в каталогах _/bin_ или _/usr/bin_).

Чтобы определить тип команды, достаточно в окне терминала ввести `type <имя_команды>`:

![](https://ravesli.com/wp-content/uploads/2021/03/5.png)

Как вы можете видеть, команды `dirs`, `pwd`, `cd` и `true` — являются внутренними командами оболочки bash. А вот команды `uname`, `id` и `whereis` — являются внешними, т.к. они ссылаются на соответствующие файлы в каталоге _/usr/bin_.

Ознакомиться с полным списком внутренних команд оболочки можно при помощи команды `help`:

![](https://ravesli.com/wp-content/uploads/2021/03/4.png)  

## Как узнать какая оболочка у меня установлена?

Если вы только начинаете свое знакомство с Linux и не меняли оболочку, то наиболее вероятно, что в вашей системе используется bash. Самый простой способ узнать, какая оболочка используется в данный момент — это обратиться к переменной окружения `SHELL`:

`echo $SHELL`

![](https://ravesli.com/wp-content/uploads/2021/03/13.png)

Кроме того, можно задействовать команду `ps –p $$`, возвращающую информацию о процессе с заданным идентификатором. В нашем случае, идентификатором оболочки являются символы `$$`:

`ps –p $$`

![](https://ravesli.com/wp-content/uploads/2021/03/14.png)

Не трудно заметить, что в настоящее время используется оболочка bash. Для просмотра всех доступных оболочек в вашей системе, необходимо обратиться к содержимому файла _/__etc/__shells_:

`cat /etc/shells`

![](https://ravesli.com/wp-content/uploads/2021/03/15.png)

  

## Типы командных оболочек

В *nix-системах существует два основных типа оболочек: оболочки на основе Bourne shell и оболочки на основе C shell.

**Типичными представителями оболочек типа Bourne shell являются:**

   sh (Bourne shell)

   bash (Bourne Again shell)

   ksh (Korn shell)

   zsh (Z Shell)

**К оболочкам типа C Shell относятся:**

   csh (C shell)

   tcsh (TENEX/TOPS C shell)

Ниже представлены некоторые из самых распространенных шеллов, используемых в *nix-системах:

![](https://ravesli.com/wp-content/uploads/2021/03/3.png)

**_Примечание:_** Термин _«*nix-системы»_ обозначает [**Unix**](https://ravesli.com/linux-protiv-unix-v-chem-raznitsa/#toc-0)-подобные операционные системы.

---

### sh (Bourne shell)

**sh** (сокр. от _«__Bourne_ _**sh**ell»_) — это самая старая (среди рассматриваемых) оболочка, написанная Стивеном Борном из AT&T Bell Labs для ОС UNIX v7. Оболочка доступна практически в любом *nix-дистрибутиве. Многие другие шеллы уходят своими корнями именно к sh. Благодаря своей скорости работы и компактности, данная оболочка является предпочтительным средством для написания shell-скриптов. К её недостаткам можно отнести отсутствие функций для использования оболочки в интерактивном режиме, а также отсутствие встроенной обработки арифметических и логических выражений.

![](https://ravesli.com/wp-content/uploads/2021/03/6.png)

**_Примечание:_** Стоит отметить, что из-за общего морального устаревания оболочки, в современных системах ссылка на шелл sh (_/bin/sh_), обычно, является псевдонимом для запуска текущей, более новой оболочки.

Характерные черты sh:

   Полные пути к интерпретатору: _/bin/sh_ и _/sbin/sh_.

   Приглашение для обычного пользователя: `$`.

   Приглашение для суперпользователя (root): `#`.

---

### bash (Bourne-Again shell)

**bash** (сокр. от _«_**_B_**_ourne–_**_A_**_gain_ **_sh_**_ell__»)_ — это усовершенствованный и дополненный вариант шелла sh, является одной из самых популярных современных командных оболочек *nix-систем.

   Совместим с sh.

   Объединяет в себе полезные фишки оболочек ksh и csh.

   Поддерживает навигацию при помощи стрелок, благодаря чему можно просматривать историю команд и выполнять редактирование прямо в командной строке.

![](https://ravesli.com/wp-content/uploads/2021/03/7.png)

Характерные черты bash:

   Полный путь к интерпретатору: _/bin/bash_.

   Приглашение для обычного пользователя: `имя_пользователя@имя_хоста:~$` (где `~` — это домашний каталог текущего пользователя, например, `mrsmith@mypc:~$`).

   Приглашение для суперпользователя (root): `root@имя_хоста:~#`.

---

### ksh (Korn shell)

**ksh** (сокр. от _«_**_K_**_orn_ **_sh_**_ell__»_) — это командная оболочка, разработанная Дэвидом Корном из AT&T Bell Labs в 1980-x годах.

   Является расширением sh.

   Имеет обратную совместимость с sh.

   Имеет интерактивный функционал, сравнимый с csh.

   Включает в себя удобные для программирования функции, такие как: встроенную поддержку арифметических выражений/функций, Си-подобный синтаксис скриптов и средства для работы со строками.

   Работает быстрее, чем csh.

   Может запускать скрипты, написанные для sh.

![](https://ravesli.com/wp-content/uploads/2021/03/7a.png)

Характерные черты ksh:

   Полный путь к интерпретатору: _/bin/ksh_.

   Приглашение для обычного пользователя: `$`.

   Приглашение для суперпользователя (root): `#`.

---

### csh (C shell)

**csh** (сокр. от _«_**_C_** **_sh_**_ell__»_) — это командная оболочка, созданная Биллом Джоем (автором редактора _vi)_ с целью усовершенствования стандартного шелла Unix (sh).

   Имеет встроенные функции для интерактивного использования, например, псевдонимы (aliases) и историю команд.

   Включает в себя удобные для программирования функции, такие как: встроенную поддержку арифметических выражений и Cи-подобный синтаксис скриптов.

![](https://ravesli.com/wp-content/uploads/2021/03/8.png)

Характерные черты csh:

   Полный путь к интерпретатору: _/bin/csh_.

   Приглашение для обычного пользователя: `%`.

   Приглашение для суперпользователя (root): `#`.

---

### tcsh (TENEX C Shell)

**tcsh** (сокр. от _«_**_T_**_ENEX_ **_C_** **_sh_**_ell__»_) — это командная оболочка, созданная Кэном Гриром, которая позиционируется как улучшенная версия шелла csh.

   Имеет полную совместимость csh.

   Именно в данном шелле впервые появилась функция автодополнения команд и путей.

   Удобна для интерактивной работы.

   Поддерживает редактор командной строки в стиле _vi_ или _emacs._

   Является стандартным шеллом во FreeBSD.

![](https://ravesli.com/wp-content/uploads/2021/03/9.png)

Характерные черты tcsh:

   Полный путь к интерпретатору: _/bin/tcsh_.

   Приглашение для обычного пользователя: `имя_хоста:~>`.

   Приглашение для суперпользователя (root): `#`.

---

### zsh (Z Shell)

**zsh** (сокр. от _«_**_Z_** **_sh_**_ell__»_) — это командная оболочка, созданная Паулем Фалстадом во время его учебы в Принстонском университете, позиционируется как свободная современная sh-совместимая командная оболочка.

   Среди стандартных шеллов больше всего похожа на ksh, но включает в себя множество улучшений.

   Встроенная поддержка программируемого автодополнения команд, имен файлов и пр.

   Поддержка проверки орфографии и опечаток.

   Раздельная история команд для одновременной работы с несколькими запущенными шеллами.

![](https://ravesli.com/wp-content/uploads/2021/03/10.png)

Характерные черты zsh:

   Полный путь к интерпретатору: _/bin/zsh_.

   Приглашение для обычного пользователя: `имя_хоста%`.

   Приглашение для суперпользователя (root): `root@имя_хоста:~#`.

---

## Резюмируем

Краткая сводная таблица для 6 вышерассмотренных командных оболочек:

|   |   |   |   |
|---|---|---|---|
|**Командная оболочка**|**Путь**|**Приглашение (обычный пользователь)**|**Приглашение (root)**|
|**sh (Bourne Shell)**|/bin/sh и /sbin/sh|$|#|
|**bash (Bourne-Again Shell)**|/bin/bash|имя_пользователя@имя_хоста:~$|имя_пользователя@имя_хоста:~#|
|**ksh (Korn Shell)**|/bin/ksh|$|#|
|**csh (C Shell)**|/bin/csh|%|#|
|**tcsh (TENEX C Shell)**|/bin/tcsh|имя_хоста:~>|#|
|**zsh (Z Shell)**|/bin/zsh|%|#|

**_Примечание:_** Помимо представленных выше оболочек, есть еще и такие оболочки, как:

   **mksh** — оболочка, основной упор в которой сделан на написание скриптов;

   **dash** — более легковесная в сравнении с bash оболочка, но из-за этого обладающая ограниченной функциональностью;

   **fish** — «новая» оболочка, написанная в 2005 году, отличительной чертой которой является упор на комфорт использования и упрощение командного языка;

   и другие.

### [Что такое bash в Linux? Гайд по созданию bash-скриптов](https://ravesli.com/bash-v-linux/)
