#user_agent #client_hints

[Client Hints vs User Agent](https://vivaldi.com/blog/technology/client-hints-or-client-lies/)

### Заголовок User Agent
#user_agent 
Заголовок User Agent уже несколько десятилетий используется для идентификации браузера, подключающегося к серверу, как в целях статистики, так и для обхода ошибок в определенных версиях браузера.

К сожалению, он также используется для блокировки браузеров, поскольку они не входят в число "поддерживаемых браузеров". Это реализовано как в виде чистых блокировок, так и более коварных, например, не отправлять тот же контент, что и для другого браузера, "потому что этот браузер все равно его не поддерживает".

Чтобы обойти такие проблемы, браузеры начали включать части идентификационных строк некоторых других браузеров, в основном основных. Возможно, это началось с Internet Explorer, если не раньше.

В Opera мы пытались идентифицировать себя как просто "Opera", без каких-либо других притязаний, но в итоге нам пришлось начать отправлять поддельные User Agents на многие сайты, потому что они блокировали нас или отправляли нам плохие данные.

Одним из наиболее примечательных случаев было то, что я называю "Catch-22 cookie" - это плохое средство проверки cookie, которое обычно работает следующим образом:

Новый пользователь загружает сайт.
Поскольку у пользователя нет никаких cookie, проверьте, поддерживает ли клиент cookie, отправив cookie.
Перенаправление на новую страницу, которая проверяет, был ли возвращен файл cookie, и, если нет, сообщает пользователю о необходимости включить cookies.
Проблема в нашем случае заключалась в том, что код на шаге 2, отправляющий cookie, сначала проверял строку User Agent по списку в модуле Client Capabilities сервера Microsoft IIS. Затем он отправлял cookie, только если в списке было указано, что User Agent поддерживает cookies. А поскольку в модуле не было Opera в списке клиентов, поддерживающих cookies, он не отправлял никаких cookies.

Поэтому, дойдя до шага 3, Opera, конечно же, не имела cookie для отправки, потому что никогда его не получала, а пользователю было предложено включить cookies. Ловушка-22!

Сайт, о котором шла речь, был довольно крупным и важным, поэтому нам нужно было его починить. Однако в итоге нам пришлось отправить исправления в Microsoft, чтобы исправить их серверный продукт.

Чтобы такой список работал, он должен быть основан на идеальных знаниях обо всех существующих клиентах, что сложно и дорого, если не невозможно.

Правильным способом проведения этого теста было бы всегда отправлять фиктивный файл cookie и удалять его после завершения теста. А список модуля возможностей должен был представлять собой список блокировки известных агентов пользователя, которым сервер не должен посылать cookies.

В компании Vivaldi мы также сталкивались с проблемами, когда идентифицировали себя как "Vivaldi" и пытались использовать пользовательские агенты на сайтах, которые ломались. В конце концов, мы сдались и начали просто идентифицироваться как Chrome на всех сайтах, за исключением тех немногих, которые, как мы знали, правильно обработают наш идентификатор Vivaldi (например, наш собственный сайт или сайт наших партнеров).

Однако проблемы могут возникнуть не только из-за названия браузера, но и из-за номера версии.

Когда Opera достигла версии 10, мы действительно столкнулись с веб-сайтами, которые считали, что версия 1.0, а не 10.0. Причина заключалась в том, что скрипты, обрабатывающие заголовок, были жестко закодированы на предположение, что перед точкой версии находится только одна цифра, поэтому двузначные числа ломали скрипт. Таким образом, нам пришлось остановить версию на 9.9 и добавить второе имя User Agent, специфичное для оперы, чтобы идентифицировать версии 10.x+.

Мы столкнулись с аналогичными проблемами, когда дошли до Vivaldi 1.10. Опять же, веб-сайты предполагали, что в номере минорной версии есть только одна цифра, поэтому 1.10 считалась 1.1. Вместо этого нам пришлось использовать 1.91 в качестве номера версии в строке User Agent.

Когда мы позже достигли версии 2.10 и по-прежнему сталкивались с обширным обнюхиванием браузеров на уровне, который делал добавление переопределений неприемлемым, мы решили "<Бля!" и перестали отправлять "Vivaldi" в общем заголовке User Agent.

Проблемы возникают не только с номерами версий клиентов. Пару месяцев назад я обнаружил, что код Chromium заморозил версию MacOS в строке User Agent на 10.15.7, последней выпущенной версии Mac OSX 10.x, потому что веб-сайты отказывались принимать запросы от машин под управлением MacOS 11 (или более поздних) и использовали это значение в части OS в строке User Agent. Упс!

На самом деле это проблема для наших отчетов об ошибках, поскольку мы записываем версию ОС из строки User Agent, когда сообщаем об ошибках. Поэтому, если пользователь не добавит дополнительную информацию, мы можем не понять, что сообщение относится к Mac OS 11, 12 или 13.

В связи с этим, год назад команде разработчиков Chromium пришлось провести длинную серию тестов при подготовке к выпуску Chromium 100, поскольку они могли столкнуться с подобными проблемами. Я предполагаю, что Mozilla сделала нечто подобное, прежде чем выпустить версию 100.

Совсем недавно была проведена работа по отказу от заголовка User Agent, начиная с сокращения информации о версии в заголовке User Agent. Chromium 106+ больше не отправляет подробную информацию о версии, только "106.0.0.0". Это часть перехода на новую систему предоставления информации о браузере: "Подсказки клиента".

### Client Hints
#client_hints 
В течение последних нескольких лет велась работа по созданию новой системы для предоставления более точной информации о браузере сайту, которая называется Client Hints.  
  
Эта новая система основана на наборе заголовков HTTP с префиксом "Sec-CH-", например, "Sec-CH-UA", новый заголовок User Agent. Существуют также заголовки для другой информации, движок браузера, устройство, ОС, разрешение документа на дисплее и т.д.  
  
Согласно стандартам, система основана на том, что сервер указывает, какие из этих заголовков он хочет получить. Затем браузер отправляет их, если он их поддерживает. Однако Chromium, по крайней мере, в настоящее время всегда отправляет три из этих заголовков, включая User Agent (Sec-CH-UA), информацию о мобильном устройстве и платформе, и может отправлять другие.  
  
Заголовок Sec-CH-UA Chrome содержит информацию о брендах браузеров и их версии (Chrome и Chromium), а также значение "бренд" под названием "Not A Brand".  
  
Значения брендов регулярно (на основе номеров версий) перемешиваются в заголовке, а значение "Not A Brand" также регулярно изменяется путем вставки различных небуквенных символов, таких как ";", ":" и ".", процесс называется "GREASE", что приводит к изменению заголовка, поэтому веб-сайты не могут полагаться на определенную последовательность значений или текст в этих значениях. Таким образом, он пытается заставить их писать парсеры, которые соответствуют стандартам и не используют короткие пути.  
  
В настоящее время Vivaldi не включает бренд в этот заголовок, отправляя только "Chromium" и значения "Not A Brand".

### Client Lies
Большой вопрос о клиентских подсказках - будут ли они (в частности, Sec-CH-UA) работать лучше для браузеров, чем строка User Agent?

Будут ли веб-сайты правильно анализировать заголовки (правда??? ) и использовать их ответственно (🤣 🙃). Или они начнут злоупотреблять этой информацией, чтобы блокировать "неподдерживаемые" браузеры (😭)?

К сожалению, первые признаки говорят о том, что одни не будут правильно анализировать, а другие будут использовать их для блокировки "неподдерживаемых" браузеров.

На данный момент мы столкнулись с двумя случаями, по одному, когда сайты не работали в Vivaldi из-за того, как сайты обрабатывали информацию заголовка Sec-CH-UA.

В первом случае сайт работал в одной версии Vivaldi, но не загружался в другой из-за проблемы на стороне сервера. Оказалось, что это связано с перестановкой значений и модификацией GREASE значения "Not A Brand". Chromium изменяет последовательность значений по-разному в каждой версии Chromium, например:

"Chromium";v="108″, "Not?A_Brand";v="8″.

В неудачной версии последовательность была "Not a Brand" и "Chromium", а значение "Not a Brand" включало символ точки с запятой (";"), который используется для разделения значений в тексте без кавычек, но является обычным символом, когда он находится в кавычках. Парсер заголовков сайта проигнорировал кавычки, в результате чего при первом значении "Not A Brand" парсер (и серверный скрипт) потерпел крах.

Дальнейшее расследование показало, что браузеры с фирменным заголовком (например, Chrome и Microsoft Edge) никогда не располагают значение "Not A Brand" в начале заголовка. У небрендированных браузеров оно было бы таким в каждой четной версии Chromium, то есть в расширенных стабильных версиях, таких как 106 и 108. И каждая третья из них будет иметь точку с запятой в строке таким образом, что это нарушит парсинг.

Мы "решили" эту проблему, заморозив последовательность, так что марка "Chromium" всегда была первой в заголовке.

На мой взгляд, часть проблемы заключается в том, что Chromium недостаточно и недостаточно часто меняет заголовок. Как уже говорилось, фирменные браузеры никогда не отправят вариацию, которая вызвала нашу проблему, и тот факт, что Chromium изменяет содержимое только в каждом выпуске Chromium, а не чаще, означает, что может потребоваться много времени (годы), чтобы обнаружить проблемы с парсером, подобные той, с которой мы столкнулись.

Отчасти причина, по которой заголовок не изменяется чаще, заключается в том, что значение заголовка может использоваться веб-сайтами в качестве части ключа для возврата кэшированных веб-страниц, запрошенных с точно таким же набором URL и определенных заголовков. Частое изменение значения заголовка увеличило бы нагрузку на систему кэширования веб-сайта и серверы.

Я по-прежнему считаю, что это не должно быть препятствием для более частого изменения последовательности.

Второй проблемой был японский сайт, который использовал API JavaScript для доступа к значениям Sec-CH-UA и по какой-то причине отказывался обслуживать запрошенный контент, если бренд не был "Chrome" или "Microsoft Edge" (Firefox был принят с помощью другого теста).

Мы еще не решили эту проблему, но, насколько мы можем судить, единственным обходным решением является использование в заголовке одного из "одобренных" брендов. Использование "Vivaldi" в качестве бренда не сработает.

Если мы столкнемся с подобными проблемами в дальнейшем, я думаю, что единственный способ избежать проблемы - это поступить так же, как мы поступали со старой строкой User Agent: притвориться Google Chrome и убедиться, что мы не отправляем никакой специфической для Vivaldi информации.

Возможно, это и не было желаемой целью для Client Hints, но если последние несколько десятилетий использования информации о строке User Agent что-то и доказали, так это то, что только основные производители (ОС или браузера) способны говорить правду. Всем остальным так или иначе придется говорить неправду - даже Microsoft пришлось говорить неправду, когда они начали распространять Internet Explorer.