
http://forum.ru-board.com/topic.cgi?forum=33&bm=1&topic=0472&start=1520#lt
Сделал регулярку для удаления дублирующих строк с текстом в Npp [?]
Код:
`(\w.*\r\n)\1+`

работает почти отлично, но если дублируется последняя строка, то её не удаляет.
 Хотелось бы и это автоматизировать. Самому не получается придумать, просьба помочь.
но если дублируется последняя строка, то её не удаляет

потому что в ней уже нет переноса строки.
добавьте руками перенос - будет.
 
можно и  
`(\w.*)\r\n(\1(\r\n)?)+ замена на \2`
 
`\w` тут точно нужен?

а руками это уже не автомат, проще тогда уже руками просто последнюю строку удалить.

Цитата:
`\w` тут точно нужен?

У меня без него цепляет только концы строк, а так как собираюсь использовать только для текста, то не мешает.

Цитата:
можно и  
 `(\w.*)\r\n(\1(\r\n)?)+ замена на \2`

Тоже не работает нормально. В частности фолсит вот на такой кусок

Код:
4uFch
htt

Тоже не работает нормально. В частности фолсит вот на такой кусок

`^(.+)\r\n(\1(\r\n)?)+ на \2`
может еще срабатывать, если в одну строчку повторяется.
 
тогда `^(.+)\r\n(\1(\r\n|$))+`

https://www.regular-expressions.info/duplicatelines.html
https://translated.turbopages.org/proxy_u/en-ru.ru.4637a44d-62a2d4fb-bcb0e0df-74722d776562/https/stackoverflow.com/questions/1573361/how-do-i-find-and-remove-duplicate-lines-from-a-file-using-regular-expressions

### Regular-expressions.info есть страница по удалению дубликатов строк из файла

Это в основном сводится к поиску этого oneliner:

`^(.*)(\r?\n\1)+$`
... И замена на \1.
Примечание: Точка не должна совпадать с новой строкой

Объяснение:

Каретка будет совпадать только в начале строки. Таким образом, механизм регулярных выражений будет пытаться сопоставить
только оставшуюся часть регулярного выражения. Комбинация точек и звезд просто соответствует всей строке, независимо от
 ее содержимого, если таковое имеется. Скобки хранят соответствующую строку в первой обратной ссылке.
Далее сопоставим разделитель строк. Я поставил знак вопроса\r?\n, чтобы заставить это регулярное выражение работать как
 с текстовыми файлами Windows (`\r\n`), так и с UNIX (`\n`). Итак, до этого момента мы сопоставляли строку и следующий разрыв строки.
Теперь нам нужно проверить, следует ли за этой комбинацией дубликат той же строки. Мы делаем это просто с \1помощью .
 Это первая обратная ссылка, которая содержит строку, которую мы сопоставили. Обратная ссылка будет соответствовать тому же тексту.
Если обратная ссылка не совпадает, совпадение регулярного выражения и обратная ссылка отбрасываются, и механизм регулярных выражений
 повторяет попытку в начале следующей строки. Если обратная ссылка выполнена успешно, символ плюса в регулярном выражении попытается
 сопоставить дополнительные копии строки. Наконец, символ доллара заставляет механизм регулярных выражений проверять,
 является ли текст, соответствующий обратной ссылке, полной строкой. Мы уже знаем, что тексту, совпадающему с обратной ссылкой,
 предшествует разрыв строки (совпадающий с `\r?\n` ). Поэтому теперь мы проверяем, следует ли за ним также разрыв строки или если
 он находится в конце файла, используя знак доллара.
Все совпадение становится line\nline(или line\nline\nlineи т. Д.). Поскольку мы выполняем поиск и замену, строка, ее дубликаты
 и разрывы строк между ними удаляются из файла. Поскольку мы хотим сохранить исходную строку, но не дубликаты,
 мы используем \1в качестве текста замены исходную строку.
 
 9
В Notepad ++ я сделал следующее, что то же самое, за исключением того, что он удаляет дубликаты,
 которые также не являются смежными (это группа без захвата посередине):
 `^(.*)$((?:\r?\n.*)*?)^\1$\r?\n?` заменено на `$1$2`, похоже, работает хорошо. 

Если порядок не имеет значения, просто

sort -u

сделает трюк

Если порядок имеет значение, но вы не возражаете против повторного запуска нескольких проходов (это синтаксис vim),
 вы можете использовать:
`%s/\(.*\)\(\_.*\)\(\1\)/\2\1/ г`

чтобы сохранить последнее вхождение, или
`%s/\(.*\)\(\_.*\)\(\1\)/\1\2/ г`

чтобы сохранить первое вхождение.

Если вы возражаете против повторного запуска нескольких проходов, чем это сложнее, поэтому,
 прежде чем мы будем работать над этим, пожалуйста, скажите об этом в вопросе!

РЕДАКТИРОВАТЬ: в вашем редактировании вы не очень ясно, но похоже,
 что вы хотите только однопроходное удаление дубликатов СОСЕДНИХ строк! Ну, это намного проще!

Простой:
`/(.*)\1*/\1/`
`(/\(.*\)\1*/\1/` в vim) т.е. Поиск `(.*)\1*` и замена его просто `\1`сделает трюк

`(.*)\1*` не соответствует дубликатам строк, потому что в вашем регулярном выражении нет ничего,
 что соответствовало бы разрыву строки между строкой и ее дубликатом. 

В RegexBuddy вы можете сделать это следующим образом:

На вкладке Библиотека загрузите библиотеку RegexBuddy.rbl, если она не загружена по умолчанию.
В поле поиска введите "дубликат".
Нажмите кнопку Использовать, чтобы загрузить регулярное выражение "удалить дубликаты строк".
На вкладке GREP укажите папку и маску файла файлов, из которых вы хотите удалить дубликаты.
В раскрывающемся меню кнопки GREP выберите Выполнить.
Если вы делаете это только для одного файла, вы можете использовать вкладку Test вместо вкладки GREP.
 Загрузите файл на вкладке Тест, а затем нажмите кнопку Заменить на главной панели инструментов.

## Как найти и удалить повторяющиеся строки из файла с помощью регулярных выражений?

https://coderoad.ru/1573361/%D0%9A%D0%B0%D0%BA-%D0%BD%D0%B0%D0%B9%D1%82%D0%B8-%D0%B8-%D1%83%D0%B4%D0%B0%D0%BB%D0%B8%D1%82%D1%8C-%D0%BF%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D1%8F%D1%8E%D1%89%D0%B8%D0%B5%D1%81%D1%8F-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D0%B8%D0%B7-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D1%80%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D1%85
Regular-expressions.info имеет страницу по удалению повторяющихся строк из файла

Это в основном сводится к поиску этого:

`^(.*)(\r?\n\1)+$`
`\1`

Объяснение:

Каретка будет совпадать только в начале строки. Таким образом, движок regex будет пытаться соответствовать только оставшейся
 части regex. Комбинация точки и звезды просто соответствует всей строке, независимо от ее содержимого, если таковое имеется.
 Скобки хранят совпадающую строку в первой обратной ссылке. Далее мы сопоставим разделитель строк. Я поставил знак вопроса в `\r?\n` ,
 чтобы этот regex работал как с текстовыми файлами Windows ( `\r\n`), так и с текстовыми файлами UNIX (`\n` ).
 Таким образом, до этого момента мы сопоставляли линию и следующий разрыв линии. Теперь нам нужно проверить,
 следует ли за этой комбинацией дубликат той же строки. Мы делаем это просто с \1 . Это первая обратная ссылка,
 которая содержит строку, которую мы сопоставили. Обратная ссылка будет соответствовать тому же самому тексту.
 Если обратная ссылка не совпадает, совпадение regex и обратная ссылка отбрасываются, и механизм regex повторяет
 попытку в начале следующей строки. Если обратная ссылка выполняется успешно, символ плюс в регулярном выражении
 попытается сопоставить дополнительные копии строки. Наконец, символ доллара заставляет механизм regex проверять,
 является ли текст, соответствующий обратной ссылке, полной строкой. Мы уже знаем, что текст, совпадающий с обратной ссылкой,
 предваряется разрывом строки (соответствует \r?\n).), Поэтому теперь мы проверяем, следует ли за ним также разрыв строки или
 он находится в конце файла, используя знак доллара . Все совпадение становится line\nline (или line`\n`line`\n`line и т. Д.).
 Поскольку мы выполняем поиск и замену, строка, ее дубликаты и разрывы строк между ними удаляются из файла.
 Поскольку мы хотим сохранить исходную строку,
 но не дубликаты, мы используем \1 в качестве текста замены, чтобы вернуть исходную строку обратно.

### Подскажите пожалуйста регулярку, чтобы найти файлы с именами, состоящими только из 20 цифр и любого расширения?

http://forum.ru-board.com/topic.cgi?forum=33&bm=1&topic=0472&start=1400#lt

чем вы будете искать? Если при помощи find, то может подойти
`find .-type f -regex '\./[[:digit:]]\{20\}\.[[:alpha:]]*$'`
или
`$ find -E . -type f -regex '\./[[:digit:]]{20}\.[[:alpha:]]*$'`
если расширение может содержать цифры замените `[[:alpha:]]` на `[[:alnum:]]`
Можно найти и так
`$ find . -type f | grep '\./[[:digit:]]\{20\}\.'`
И т.п.

### Как найти слово:  
http://forum.ru-board.com/topic.cgi?forum=33&bm=1&topic=0472&start=780#lt
https://regex101.com/
https://regex101.com/r/vNXVTy/2/

1. по первым нескольким буквам
`(\W|^)(abc\w+)`

2. по буквам в середине 
`\w+abc\w+ `

3. в конце
`(\w+abc)(\W|$)`

### My Useful

Для захвата скобок с содержимым я бы предложил
Код:
`\([^)]+\)`

В файле много строк такого вида: 
Код:
`"https://4pda.ru","Locus","Figocus",,"","{d190069}","159456","159456","15945685"`

 Нужно во всех этих строках удалить "хвосты", начиная от третьей по счету запятой и до конца строки.
 Эту третью по счету запятую нужно тоже удалять. 
Чтоб получились строки вида: 
`"https://4pda.ru","Locus","Figocus"`

например `(.*,.*,.*),.*`  или  (.*?,.*?,.*?),.*  => ` \1`  или  `$1`

Заменить все точки кроме последней на пробелы.
Например,
Александр.Пушкин.Капитанская.дочка.pdf -> Александр Пушкин Капитанская дочка.pdf
\.`(?=([^\.\n\r]*\.[^\.\n\r]*)+$)`
заменить на пробел
http://forum.ru-board.com/topic.cgi?forum=33&bm=1&topic=0472&start=1340#lt
Цитата:
2. Необходимо пометить строки, которые отстают на 2 строки от пометки.  

Строки с пометками как-то были найдены? Можно использовать тот же рег.выр. типа:
`(.+?)(?=\r\n[^\r\n]+?\r\n[^\r\n]+?\r\n` ваша_строка_с_пометками
будет найдена строка после которой следует 2 строки и строка с пометкой выраженная через рег.выр.

Подскажите, как выделить все строки, где одни пунктиры, и заменить их на один и тот же текст.
  Проблема в том, что пунктиров в каждой строке разное количество, но их много:
 ----------------------------------------------
--------------------------------------
-----------------------------------------
----------------------------------------------------------
------------------------------------------------
Ctrl + H
В левом нижнем углу, Режим поиска переключаете на Регуляр.выражен.
В поле Найти пишете: `[-]+`
В поле Заменить слово/текст, которым хотите заменить строки с пунктирами
Заменить все
Готово
Спасибо. Почему-то в строках, где например 2014-03-10, тире тоже заменяются.
 Я попробовал наугад и получилось с такой формулой:` [-]+-----`

Вот такие строки надо выделить и заменить их словом.
Код:
`(?m)^-+(?=\r?$)`
`(?m)^\h*?-+\h*?(?=\r?$)`
`(?m)^[\h-]+(?=\r?$)`
поверяет, что тире заканчивается концом строки, а не текстом, а начинается с начала строки. То есть в строке только "-".
Второй вариант удаляет даже в случае пробелов в начале и в конце строки.

http://forum.ru-board.com/topic.cgi?forum=33&bm=1&topic=0472&start=1440#lt
Можно ли с помощью регулярных выражений вырезать или скопировать слово и вставить его в конец
 другой строки после определенного слова или символа? Сами вырезаемые слова разные
 (но одного формата, например 000-00-00 или (00:00) или AB000), а слова и символы,
 после которых они вставляются в конце другой строки, одни и те же
 
Пример: 
`0001-01-01 AB001 ..... . .... .. ..... (01:01)`
`AAAAAAA`
`BBBBBB`
`CCCCC`
 
`0002-02-02 AB002 ..... . .... .. ..... (02:02)`
`AAAAAAA`
`BBBBBB`
`CCCCC`
 
Нужно:
 
`AB001 ..... . .... .. .....`
`AAAAAAA AB001`
`BBBBBB 0001-01-01`
`CCCCC 01:01`
 
`AB002 ..... . .... .. .....`
`AAAAAAA AB002`
`BBBBBB 0002-02-02`
`CCCCC 02:02`

зависит от используемых средств, обратных ссылок на группы, символа новой строки и тд и тп.
например так https://regex101.com/r/Mv092a/1
щелкните мою ссылку, вставьте свой текст в верхнее поле и посмотрите результат.

Круто, получилось. Огромное спасибо! Теперь кажется понял принцип с блоками.
 
Добавление: Я немного модифицировал ваш код:
Было:
`([\d\-]+)\s+([^\s]+)\s+(.*)\s+\(([\d:]+)\)\r?\n(.*)\r?\n(.*)\r?\n(.*)`
`$2 $3\n$5 $2\n$6 $1\n$7 $4`  
Стало:
`([\d\-]+)\s+\[([^\(]*)\]\s+(.*)\s+\(([\d:]+)\)\r?\n(.*)\r?\n(.*)\r?\n(.*)`
`\[$2\] $3\n$5 $2\n$6 $1\n$7 $4`
 
Так при копировании второго слова убираются его квадратные скобки:
Код:
`0001-01-01 [AB001] ..... . .... .. ..... (01:01)`
`AAAAAAA`
`BBBBBB`
`CCCCC`
 
`[AB001] ..... . .... .. .....`
`AAAAAAA AB001`
`BBBBBB 0001-01-01`
`CCCCC 01:01`
 
Еще для себя я добавил  `\n(.*)` к поиску и `\n$8` к замене, так как у меня там есть еще восьмое слово,
 строка с которым не меняется, поэтому я не рассказывал про него.

==================================
http://forum.ru-board.com/topic.cgi?forum=33&bm=1&topic=0472&start=1440
Гуру, подскажите, пожалуйста.
Возможно ли регулярками найти строки заканчивающиеся на слеш "/",
 но при этом не находить строки в которых слешей больше чем один?
 
Иванов/Иван/Иванович
Иванов//Иван//Иванович/
Иванов Иван Иванович/ <- найти нужно только эту

зависит от того, в чем использовать.
https://regex101.com/r/amk7Vv/1

`/^[^\/]+\/$/gm`

http://forum.ru-board.com/topic.cgi?forum=33&bm=1&topic=0472&start=1360#lt

Подскажите, пожалуйста, как достать значение параметра "fiasGuid" `bbfc92f6-9c7a-40b8-8261-78e6ef0813ff`, причем вхождение в строку может быть разное, типа:
1 пример: `{"row":"1","visible":TRUE,"autofill":TRUE,"AddType":"ADDRESS","fias":0,"fiasGuid":"bbfc92f6-9c7a-40b8-8261-78e6ef0813ff"}`
2 пример: `{"row":"50","rowin":"40","visible":FALSE,"AddType":"ADDRESS","fias":0,"fiasGuid":"9fb3d08f-ff93-46a4-859a-1ab0026430c2"}`

Код:
`"fiasGuid"\s*:\s*"(\b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b)"`

Сам uuid без кавычек находится в захваченной группе `$1`.



